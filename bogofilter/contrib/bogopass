#! /usr/bin/env perl
# $Id$

# bogopass -- emulate bogofilter -p with base64 decoder
# Copyright (C) 2002, Suzanne Skinner
# ----------------------------------------------------------------------
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
# ----------------------------------------------------------------------

# bogopass emulates the -p (passthrough) option of bogofilter with
# base64 decoding. It takes an e-mail message on stdin, filters it
# through unbase64, then sends it to bogofilter with the "-v" option.
# The X-Bogosity header output by bogofilter is added to the original
# message by [re]formail, and the updated message is output to stdout.
#
# Limitation: the spamicity header MUST be UNchanged from the default,
#             X-Bogosity:
#
# Any options given to bogopass will be passed on to bogofilter along
# with "-v". For instance, call "bogopass -g" to use the Graham
# algorithm.
#
# This script requires either:
# - formail, part of the procmail suite,
# - reformail, part of the maildrop suite.
#
# get maildrop at: http://www.flounder.net/~mrsam/maildrop/README.html
# get procmail at: http://www.procmail.org/

require 5.004;
use strict;
use File::Temp qw(tempfile unlink0);
use IO::Handle;
use Carp;
use POSIX;

sub my_die($ );
sub parsewait($ );

my $PROG = 'bogopass';

sub werr($ ) {
    my ($f) = shift;
    my_die("Error writing to temporary file $f: $!");
}

### Begin Main ###

# search for reformail and formail
my $formail = '';
foreach (split /:/, $ENV{PATH}) {
    if (-x "$_/formail")   { $formail = "$_/formail"; last; }
    if (-x "$_/reformail") { $formail = "$_/reformail"; last; }
}

my_die("Cannot find either reformail or formail on the PATH.")
  unless $formail;

# write standard input (original mail) to a temporary file
my ($origh, $orign) = tempfile("/tmp/$PROG.XXXXXXXXXX");
while (<STDIN>) {
    print $origh $_ or werr($orign);
}
defined $origh->flush or werr($orign);
# do not close $origh here, we still need it for File::Temp::unlink0 later.

# run unbase64 on original mail
# then run bogofilter on the decoded mail and extract the spamicity
# header.
my ($h2, $n2) = tempfile("/tmp/$PROG.XXXXXXXXXX");
my $r;
($r = (system "unbase64 <\"$orign\" >>\"$n2\"")) == 0 or
    my_die("Error executing unbase64: " . parsewait($r));

my $options = join ' ', @ARGV;
my $bf = 'bogofilter';
my $bogo_header = `$bf -v $options <"$n2"`;
$r = $?;
my_die "$bf failed: " . parsewait($r)
    unless defined $bogo_header
      and (POSIX::WIFEXITED($r)
	  and (POSIX::WEXITSTATUS($r) == 0 
	      or POSIX::WEXITSTATUS($r) == 1));
chomp $bogo_header;
$bogo_header =~ /^X-Bogosity:/ or
    my_die "bogofilter returned invalid output (\"$bogo_header\")";
unlink0 ($h2,$n2) or
    my_die "cannot unlink temporary file $n2: $!";
close $h2 or my_die("Error closing temporary file $n2: $!");

# add the extracted spamicity header to the original mail
# and print it on stdout
system("$formail -I \"$bogo_header\" < \"$orign\"") == 0 or
    my_die "$formail failed (" . parsewait($?) . ")";
# kill original temporary file
unlink0 ($origh,$orign) or
    my_die "cannot unlink temporary file $orign: $!";
close $origh or my_die("Error closing temporary file $orign: $!");
exit 0;

### End Main ###

# as die, but prepend our program name
sub my_die($ ) {
    my $msg = shift;
    croak "$PROG: $msg";
}

# figure if the pipe open failure code was because the child crashed
# or returned a nonzero exit condition.
sub parsewait($ ) {
    my $c = shift;
    my $r;
    if (POSIX::WIFSIGNALED($c)) {
	$r = sprintf("signal %u", POSIX::WTERMSIG($c));
    } else {
	$r = sprintf("exit code %u", POSIX::WEXITSTATUS($c));
    }

    return wantarray ? ($r) : $r;
}
