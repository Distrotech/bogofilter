#!/usr/bin/env perl
# $Id$

# bogopass -- emulate bogofilter -p with base64 decoder
# Copyright (C) 2002, Suzanne Skinner
# ----------------------------------------------------------------------
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
# ----------------------------------------------------------------------

# bogopass emulates the -p (passthrough) option of bogofilter with
# base64 decoding. It takes an e-mail message on stdin, filters it
# through unbase64, then sends it to bogofilter with the "-v" option.
# The X-Bogosity header output by bogofilter is added to the original
# message by formail, and the updated message is output to stdout.
#
# Any options given to bogopass will be passed on to bogofilter along
# with "-v". For instance, call "bogopass -g" to use the Graham
# algorithm.
#
# This script requires formail (part of the procmail suite).

require 5.004;
use strict;
use File::Temp qw(tempfile unlink0);
use IO::Handle;

sub my_die($ );
sub parsewait($ );

my $PROG = 'bogopass';

sub werr($ ) {
    my ($f) = shift;
    my_die("Error writing to temporary file $f: $!");
}

### Begin Main ###

my ($fh, $fn) = tempfile("/tmp/$PROG.XXXXXXXXXX");
while (<STDIN>) {
    print $fh $_ or werr($fn);
}
defined $fh->flush or werr($fn);

my ($h2, $n2) = tempfile("/tmp/$PROG.XXXXXXXXXX");
my $r;
($r = (system "unbase64 <\"$fn\" >>\"$n2\"")) == 0 or
    my_die("Error executing unbase64: " . parsewait($r));

my $options = join ' ', @ARGV;
my $bogo_header = `bogofilter -v $options <"$n2"`;
my_die "bogofilter failed" unless defined $bogo_header;
chomp $bogo_header;
$bogo_header =~ /^X-Bogosity:/ or
    my_die "bogofilter returned invalid output (\"$bogo_header\")";
unlink0 ($h2,$n2) or
    my_die "cannot unlink temporary file $n2: $!";
close $h2 or my_die("Error closing temporary file $n2: $!");

system("formail -I \"$bogo_header\" < \"$fn\"") == 0 or
    my_die "formail failed (" . parsewait($?) . ")";
unlink0 ($fh,$fn) or
    my_die "cannot unlink temporary file $fn: $!";
close $fh or my_die("Error closing temporary file $fn: $!");
exit 0;

### End Main ###

# as die, but prepend our program name
sub my_die($ ) {
    my $msg = shift;
    die "$PROG: $msg";
}

# figure if the pipe open failure code was because the child crashed
# or returned a nonzero exit condition.
sub parsewait($ ) {
    my $c = shift;
    my $r;
    if ($c & 255) {
	$r = sprintf("signal %u%s", $c & 127, $c & 128 ? " (core dumped)" : "");
    } else {
	$r = sprintf("exit code %u", $c >> 8);
    }

    return wantarray ? ($r) : $r;
}
