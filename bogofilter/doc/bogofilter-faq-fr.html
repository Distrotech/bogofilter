<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
    

    <title>Bogofilter FAQ</title><style type="text/css">
    <style type="text/css">
      h2 {
	margin-top: 1em;
	font-size: 125%;
      }
      p {
        margin-top : 0.5em;
        margin-bottom: 0.5em;
      }
      ul {
	margin-top: 1.5em;
	margin-bottom: 0.5em;
      }
      ul ul {
	margin-top: 0.25em;
	margin-bottom: 0;
      }
      li {
	margin-top: 0;
	margin-bottom: 1em;
      }
      li li {
	margin-bottom: 0.25em;
      }
      dt {
	margin-top: 0.5em;
	margin-bottom: 0;
      }
      hr {
	margin-top: 1em;
	margin-bottom: 1em;
      }
    </style></head>


  <body>
    <h1>FAQ Bogofilter</h1>

     <p>Versions Officielles : en
     <a href="http://bogofilter.sourceforge.net/bogofilter-faq.html">Anglais</a> ou 
     <a href="http://bogofilter.sourceforge.net/bogofilter-faq-fr.html">Français</a><br>

     Mainteneur: David Relson &lt;relson@osagesoftware.com&gt;<br>
     Traducteur: Fabrice Prigent &lt;Fabrice.Prigent@univ-tlse1.fr&gt;</p>

    <p>Ce document a pour but de répondre aux questions fréquemment
    posées sur Bogofilter.</p>

    <ul>
      <li>
        Information générale

        <ul>
          <li><a href="#what-is-bogofilter">Qu'est ce que
          Bogofilter?</a></li>

          <li><a href="#bogo-what">Bogo-quoi?</a></li>

          <li><a href="#lists">Listes de diffusion
          Bogofilter</a></li>
        </ul>
      </li>

      <li>
        Questions opérationnelles 

        <ul>
	  <li><a href="#train-on-error">Qu'est-ce que "l'entrainement sur erreur" et
	  "l'entrainement sur épuisement"?</a></li>
	 
          <li><a href="#training">Comment débuter l'apprentissage de Bogofilter?</a></li>
	  
          <li><a href="#production">Comment conserver une bonne d'acuité?</a></li>
	  
          <li><a href="#spamassassin">Comment puis-je utiliser
          SpamAssassin pour entraîner Bogofilter?</a></li>

          <li><a href="#vvv">Que signifie la sortie verbeuse de
          Bogofilter?</a></li>

          <li><a href="#asian-spam">Comment traiter les spams
          asiatiques?</a></li>

        </ul>
      </li>

      <li>
        Questions sur les bases de données

        <ul>
          <li><a href="#query-database">Comment faire une requête
          manuelle sur la base de données?</a></li>

          <li><a href="#rescue">Comment faire si ma base de mots
          est corrompue?</a></li>
        </ul>
      </li>

      <li>
        Problèmes techniques

        <ul>
          <li><a href="#port-notes">Comment puis-je faire
          fonctionner Bogofilter sur Solaris, BSD, etc.?</a></li>

          <li><a href="#nfs">Puis-je partager une liste de mots par
          NFS?</a></li>

          <li><a href="#return-codes">Pourquoi Bogofilter retourne
          les codes erreurs tels que 0 et 256 quand il est appelé
          par un programme?</a></li>

          <li><a href="#changed-options">Pourquoi, depuis que j'ai
          installé la 0.11, mes scripts ne fonctionnent
          plus?</a></li>

          <li><a href="#changed-exitcodes">Pourquoi, depuis que j'ai
          installé la 0.14, mes scripts ne fonctionnent-ils
          plus?</a></li>

          <li><a href="#changed-tagging">Pourquoi, depuis que j'ai
          installé la 0.15, Bogofilter fonctionne-t-il moins bien?</a></li>
	  
	  <li><a href="#remove-spam-or-nonspam"> Avec une wordlist combinée, comment
	  	puis-je détruire tous les tokens spams (ou les non-spams) ?
		?</a></li>
        </ul>


      <li>
        Problèmes techniques

        <ul>
          <li><a href="#port-notes">Comment puis-je faire
          fonctionner Bogofilter sur Solaris, BSD, etc.?</a></li>
        </ul>

      </li>
    </ul>

    <hr>

    <h2 id="what-is-bogofilter">Qu'est ce que Bogofilter?</h2>

    <p>Bogofilter est un filtre bayésien rapide basé sur les travaux de
    <a href="http://www.paulgraham.com/">Paul Graham</a>
    dans son article <a href="http://www.paulgraham.com/spam.html">Un plan contre le
    Spam</a>. Bogofilter utilise l'algorithme de moyenne géométrique de
    <a href="http://radio.weblogs.com/0101454/stories/2002/09/16/spamDetection.html">
    Gary Robinson</a> avec la méthode modifiée de Fisher (khi2)
    pour classifier les spams et hams (N.D.T.: les mails autres que
    des spams).</p>

    <p>La page web de <a href="http://bogofilter.sourceforge.net/">Bogofilter</a> chez
    SourceForge est le point central pour toutes les ressources sur
    Bogofilter.</p>

    <p>Bogofilter a été créé par <a href="http://catb.org/~esr/">Eric
    S. Raymond</a> le 19 Août 2002.  Il a gagné en popularité depuis
    Septembre 2002, et un grand nombre de programmeurs ont commencé à
    participer au projet.</p>

    <p>Le fichier <a href="http://bogofilter.sourceforge.net/NEWS">NEWS</a> décrit
    l'historique des versions de Bogofilter.</p>

    <hr>

    <h2 id="bogo-what">Bogo-quoi?</h2>

    <p>Bogofilter est une sorte de bogomètre 
    <a href="http://www.catb.org/~esr/jargon/html/B/bogometer.html">(bogometer)</a>
    ou filtre à bogues 
    <a href="http://www.catb.org/~esr/jargon/html/B/bogon-filter.html">(bogon-filter)</a>,
    c'est à dire qu'il essaie d'identifier des mails bogués 
    <a href="http://www.catb.org/~esr/jargon/html/B/bogus.html">(bogus)</a>
    en mesurant leur bogosité 
    <a href="http://www.catb.org/~esr/jargon/html/B/bogosity.html">(bogosity)</a>.</p>

    <hr>

    <h2 id="lists">Listes de diffusion</h2>

    <p>Il existe actuellement 4 listes de diffusion pour
    Bogofilter:</p>

    <table border="1" width="100%">
      <tbody>
        <tr>
          <th>Adresse de la liste</th>

          <th>Liens</th>

          <th>Description</th>
        </tr>

        <tr>
          <td>bogofilter-announce@aotto.com</td>

          <td><a href="mailto:bogofilter-announce-subscribe@aotto.com">[abonnement]</a>
	  <a href="http://news.gmane.org/thread.php?group=gmane.mail.bogofilter.announce">[archive]</a></td>

          <td>Une liste où sont annoncées les nouvelles
          versions.</td>
        </tr>

        <tr>
          <td>bogofilter@aotto.com</td>

          <td><a href="mailto:bogofilter-subscribe@aotto.com">[abonnement]</a>
	  <a href="http://news.gmane.org/thread.php?group=gmane.mail.bogofilter.general">[archive]</a></td>

          <td>Une liste de diffusion généraliste sur
          Bogofilter.</td>
        </tr>

        <tr>
          <td>bogofilter-dev@aotto.com</td>

          <td><a href="mailto:bogofilter-dev-subscribe@aotto.com">[abonnement]</a>
	  <a href="http://news.gmane.org/thread.php?group=gmane.mail.bogofilter.devel">[archive]</a></td>

          <td>Une liste pour des échanges de patches, le
          développement, et les discussions techniques.</td>
        </tr>

        <tr>
          <td>bogofilter-cvs@lists.sourceforge.net</td>

          <td><a href="http://lists.sourceforge.net/mailman/listinfo/bogofilter-cvs">[abonnement]</a>
	  <a href="http://sourceforge.net/mailarchive/forum.php?forum=bogofilter-cvs">[archive]</a></td>

          <td>Une liste pour annoncer les changements de code sur
          l'archive CVS.</td>
        </tr>
      </tbody>
    </table>

    <hr>

    <h2 id="training">Comment débuter l'apprentissage de Bogofilter?</h2>
    <p>Pour classifier les messages comme ham ou spam, Bogofilter
    a besoin d'apprendre votre courrier. Pour commencer, le mieux est d'avoir
    un corpus (aussi large que possible) de messages dont vous êtes sûr de
    l'état de ham ou de spam. (Des erreurs à ce stade occasionneront des problèmes plus tard,
    aussi, soyez attentifs <code>;-)</code>). Attention, n'utilisez que votre email. L'utilisation d'autres
    corpus (tel qu'un corpus trouvé sur Internet), peut pousser
    Bogofilter à tirer de mauvaises conclusions&#8212; après tout, votre but est de lui
    faire comprendre <em>votre</em> courrier.</p>
    
    <p>Une fois que vous avez vos corpus de spam et de ham, vous avez quatre
    choix possibles. Dans tous les cas, cela fonctionnera mieux si votre base
    d'apprentissage (les corpus ci-dessus) est conséquente. Plus un corpus est
    petit, plus grand sera le nombre d'erreurs que fera Bogofilter en production. Supposons
    que vos corpus se trouvent dans deux fichiers mbox: ham.mbx et spam.mbx.</p>

    <ul>
    <li><p>Méthode 1) Entrainement complet : Entraînez Bogofilter avec tous vos messages. Dans notre
    example :</p>
    <pre>    bogofilter -s &lt; spam.mbx
    bogofilter -n &lt; ham.mbx</pre></li>
    </ul>
    <p>Note : Le répertoire contrib de Bogofilter contient 2 scripts qui tous les deux utilisent une
    technique d'entrainement sur erreur. Cette technique évalue chaque message et n'ajoute à la
    base de données que les messages qui ont été mal évalués (messages marqués comme incertains, ham
    évalués en tant que spam ou inversement). Le but est de créer une base de données des mots réellement
    <em>nécessaires</em> pour classer correctement les messages. La base de données résultante est plus
    petite que celle de l'entrainement complet.</p>
    <ul>

    <li><p>Méthode 2) Utilisez le script  bogominitrain.pl (dans le répertoire contrib).
    Il évalue les messages le même ordre que vos fichiers mailbox. Vous devriez utiliser
    l'option -f qui va demander au script de répéter le travail, jusqu'à ce que tous
    les messages soient classés correctement.
    (Si nécessaire, vous pouvez même ajuster le niveau de certitude). Comme le script s'assure
    que la base de données
    connaît "tout" votre corpus d'entrainement (avec la précision de votre choix), cela
    fonctionne très bien. Vous pouvez utiliser <code>-o</code> pour créer une marge de
    sécurité autour de "spam_cutoff" 
    Avec spam_cutoff=0.6 vous voudrez peut-être évaluer tous les hams
    dans votre corpus en dessous de 0.3 et tous les spams au delà de 0.8. Notre exemple devient:</p>

    <pre>    bogominitrain.pl -fnv ~/.bogofilter ham.mbx spam.mbx '-o 0.8,0.3'</pre></li> 

    <li><p>Méthode 3) Utilisez le script randomtrain (dans le répertoire contrib).
    Le script génère une liste de tous les messages dans les mailbox, mélange la liste, puis
    évalue chaque message, suiv d'un entrainement si nécessaire. Dans notre exemple:</p>

    <pre>     randomtrain -s spam.mbx -n ham.mbx </pre>
    
    <p>Comme pour la méthode 4, cela fonctionne mieux si vous commencer avec un corpus
    d'entrainement de plusieurs milliers de messages. Ceci vous donnera une base de données
    plus complète et significativement plus grande.</p></li>

    <li><p>Méthode 4)  Si vous avez suffisamment de spam et de ham dans votre corpus, "réservez"
    10000 spams et 10000 hams dans des fichiers mbox séparés, puis utilisez ce corpus pour
    l'entraînement. Lancez alors Bogofilter pour classer les spams et hams restants. Prenez tout message
    incorrectement évalué ou ayant le statut incertain, et utilisez les pour un nouvel apprentissage. Cette méthode
    donne la meilleure méthode possible de discrimination. Voici deux petits scripts qui peuvent
    être utilisés pour classifier les messages "mauvais élèves".</p>
    <pre> 	#! /bin/sh
	#  class3 -- classe un message en mauvais, bon ou incertain
	cat &gt;msg.$$
	bogofilter $* &lt;msg.$$
	res=$?
	if [ $res = 0 ]; then
	    cat msg.$$ &gt;&gt;corpus.bad
	elif [ $res = 1 ]; then
	    cat msg.$$ &gt;&gt;corpus.good
	elif [ $res = 2 ]; then
	    cat msg.$$ &gt;&gt;corpus.unsure
	fi
	rm msg.$$</pre>

     <pre>	#! /bin/sh
	# classify -- Place tous les messages dans un fichier mbox à l'aide de class3
	src=$1;
	shift
	formail -s class3 $* &lt;$src</pre>

    <p>Dans notre exemple (après l'entrainement initial):</p>

    <pre>	classify spam.mbx [bogofilter options]
        bogofilter -s &lt; corpus.good
        rm -f corpus.*
        classify ham.mbx [bogofilter options]
        bogofilter -n &lt; corpus.bad
	rm -f corpus.*</pre></li>
    </ul>
    <h3>Comparaison de ces méthodes</h3>
    <p>Il est important de comprendre les conséquences des méthodes que
    nous venons de décrire. Faire un entrainement complet, tel que dans les
    méthodes 1 et 4 produit une base de données plus grande que ne le
    ferait un entrainement avec les méthodes 2 ou 3. Si votre base de données
    doit être de petite taille (par exemple à cause de quotas), utilisez les
    m&eacute;thodes 2 ou 3.</p>
    <p>L'entrainement avec la méthode 1 est le plus rapide. L'entrainement sur erreur
    (tel que décrit dans les méthodes 2,3 et 4) est efficace, mais
    l'apprentissage est plut&ocirc;t lent.</p>

    <hr>
 
    <h2 id="train-on-error">Qu'est-ce que "l'entrainement sur erreur" et "l'entrainement sur épuisement"?</h2>

    <p>"L'entrainement sur erreur" implique l'analyse d'un corpus de messages dont le statut de spam ou ham
    est connu. Seuls ceux qui sont mal classés, ou dont le classement est incertain, seront intégrés dans
    la base de données d'apprentissage. Il a été montré que la sélection des seuls messages "mauvais élèves" était
    un moyen efficace d'entrainement. Si l'on entrainait Bogofilter avec tous les messages, il va
    réapprendre avec des spams ou hams évidents. L'apprentissage est un peu plus rapide si l'on a commencé
    avec une période d'entrainement "brut" de 10 000 spams et 10 000 hams.)</p>

    <p> Cette méthode peut être améliorée en utilisant une "marge de
    sécurité". En augmentant la valeur "spam cutoff" et en diminuant la valeur "ham cutoff",
    les messages qui sont proches du seuil seront utilisés, pour l'entrainement. L'utilisation de
    cette marge de sécurité a montré son efficacité à améliorer les
    résultats dans l'entrainement sur erreur.</p>
           
    <p>"L'entrainement sur épuisement" est la répétition de l'entrainement sur erreur, avec le même corpus
    de messages, jusqu'à ce que plus aucune erreur ne subsiste. Ceci a bien fonctionné sur plusieurs tests,
    mais peut être risqué.</p>

    <p>Un des postulats de base de la théorie de Bayes est que les messages utilisés représentent
    un échantillon aléatoire des messages reçus. Ceci est en contradiction avec le fait de choisir des
    messages en les analysant en priorité. Mais, meme théoriquement faux, en pratique, "l'entrainement
    sur erreur" semble fonctionner.</p>

    <p>L'intégration multipliée de messages (telle que décrite dans l'entrainement sur épuisement).
    crée une distribution des tokens dans la base de données qui diffère de celle des messages d'entrée.
    Ceci constitue une violation des postulats de la classification bayésienne, et peut donc aboutir
    à des résultats imprévisibles. Mais, même théoriquement faux, en pratique, "l'entrainement
    sur épuisement" semble fonctionner.</p>

    <p>Les tokens qui apparaissent "normalement" de manière plus ou moins équitable
    dans les deux catégories, peuvent, s'ils
    sont présents dans un message d'une catégorie et avec le phénomène de répétition,
    faire pencher la balance. De tels effets
    sont temporaires, mais peuvent dégrader l'acuité pendant leur durée.</p>

    <p>
    Note: <code>bogominitrain.pl</code> possède une option <code>-f</code> qui permet de réaliser
    "l'entrainement sur épuisement". Si
    vous choisissez de l'utiliser, soyez conscient des effets secondaires possibles. L'utilisation
    de <code>-fn</code> évite de répéter l'entrainement pour chaque message.</p>

    <hr>

    <h2 id="production">Comment puis-je conserver une bonne acuité ?</h2>
    <p>Bogofilter fera des erreurs de temps en temps. C'est pourquoi un
    apprentissage régulier est important. Il existe principalement deux méthodes pour le faire.
    Premièrement, vous pouvez l'entraîner avec chaque nouveau message (en utilisant l'option
    -u). Deuxièmement, vous pouvez ne l'entraîner que sur des erreurs.</p>
    
    <p>De plus, vous pouvez reconstruire votre base à certains moments,
    par exemple quand une nouvelle fonctionnalité importante est ajoutée à Bogofilter.
    Il peut être alors fort utile de mettre à jour régulièrement votre corpus d'apprentissage.</p>
    
    <p>Bogofilter fait toujours de son mieux avec les informations
    disponibles. Cependant, il fera des erreurs, tel que classer des ham en spam
    (faux positifs) ou spam en ham (faux négatifs). Pour réduire la probabilité d'un réapparition
    de l'erreur, il sera nécessaire d'entrainer Bogofilter avec le message erroné. Si un message est
    classé incorrectement spam, utilisez l'option <code>-n</code> pour l'intégrer en tant que ham.
    Utilisez l'option <code>-s</code> pour l'intégrer en tant que spam.</p>

    <p>Bogofilter a une option <code>-u</code> qui, automagiquement, met à jour la liste des mots
    après chaque évaluation de messages. Comme Bogofilter fait parfois des erreurs, cette méthode a
    l'inconvénient de dégrader la base d'entrainement avec des entrées erronées. Vous aurez alors
    besoin de la regarder et la corriger fréquemment.
    La correction peut être faite en utilisant <code>-Sn</code> pour changer la classification du message
    de spam en ham et <code>-Ns</code> pour changer de ham en spam.
    
    <p>Corriger un message incorrectement classé peut affecter la classification d'autres
    messages. Plus votre base de données sera petite, plus grande sera la probabilité qu'une
    erreur d'apprentissage créee des classifications incorrectes.</p>
    
    <p>L'utilisation de la méthode 2 ou 3 (ci-dessus) peut compenser cet effet.
    Repéter l'entrainement avec le corpus complet (y compris les messages de corrections ajoutés
    depuis le précédent apprentissage). Ceci ajoutera des messages dans la base de données afin
    que d'atteindre un nouvel équilibre, annulant les effets éventuellement de "surcompensation".</p>

    <p>Une stratégie alternative, basée sur la méthode 4 de
    la section précédente est la suivante : Périodiquement, prenez des blocs de messages et utilisez les
    scripts de la méthode 4 pour les classer. Analyser manuellement les spams, ham et incertains, corriger
    les erreurs, puis séparer les incertains en hams et spam. Jusqu'à ce que vous ayez 10000 spams et 10000 hams
    dans votre base d'apprentissage, entraînez avec les hams, les spams, puis les erreurs et enfin les incertains.
    Plus tard, vous n'entrainerez qu'avec les erreurs et les incertains, en ignorant les messagess que Bogofilter
    a correctement classé.
    </p>

    <p>Notez que vous devrez régulièrement lancer :</p>

    <pre>    bogoutil -d wordlist.db | bogoutil -l wordlist.db.new
    mv wordlist.db wordlist.db.prv
    mv wordlist.db.new wordlist.db</pre>
    <p>ou pour les fichiers spamlist.db et goodlist.db (si vous utilisez Bogofilter avec
    les listes de mots séparés). Ceci compressera les bases de données pour n'occuper que le
    minimum d'espace disque nécessaire.
  
    </p>

    <hr>

    <h2 id="spamassassin">Comment puis-je utiliser SpamAssassin
    pour l'apprentissage de Bogofilter?</h2>

    <p>Si vous avez un SpamAssassin actif (ou si vous voulez en
    créer un), vous pouvez utiliser ses codes de retour pour
    l'apprentissage de Bogofilter. Le moyen le plus simple est de
    créer un script pour votre MDA qui fait tourner SpamAssassin,
    tester l'état du code de retour spam/ham, et lancer Bogofilter
    pour valider le message. Le script procmail ci-dessous est un
    moyen de le faire:</p>
    <pre>	BOGOFILTER     = "/usr/bin/bogofilter"
	BOGOFILTER_DIR = "training"
	SPAMASSASSIN  = "/usr/bin/spamassassin"

	:0 HBc
	* ? $SPAMASSASSIN -e
	#spam yields non-zero
	#non-spam yields zero
	| $BOGOFILTER -n -d $BOGOFILTER_DIR
	#else (E)
	:0Ec
	| $BOGOFILTER -s -d $BOGOFILTER_DIR

	:0fw
	| $BOGOFILTER -p -e

	:0:
	* ^X-Bogosity:.Yes
	spam

	:0:
	* ^X-Bogosity:.No
	non-spam</pre>
  
<hr>

    <h2 id="vvv">Quelle est la signification de la sortie verbeuse
    de Bogofilter?</h2>

    <p>On peut dire à Bogofilter d'afficher des informations sur
    l'évaluation d'un message en le lançant avec les paramètres
    "-v", "-vv", "-vvv", or "-R".</p>

    <ul>
      <li>
        En utilisant "-v", Bogofilter génère la ligne d'entête
        "X-Bogosity:", par exemple
	<pre>  X-Bogosity: No, tests=bogofilter, spamicity=0.500000</pre></li>

      <li>
        En utilisant "-vv" Bogofilter génère un histogramme, par
        exemple 
<pre>  X-Bogosity: No, tests=bogofilter, spamicity=0.500000
          int  cnt    prob   spamicity  histogram
         0.00   29  0.000209  0.000052  #############################
         0.10    2  0.179065  0.003425  ##
         0.20    2  0.276880  0.008870  ##
         0.30   18  0.363295  0.069245  ##################
         0.40    0  0.000000  0.069245
         0.50    0  0.000000  0.069245
         0.60   37  0.667823  0.257307  #####################################
         0.70    5  0.767436  0.278892  #####
         0.80   13  0.836789  0.334980  #############
         0.90   32  0.984903  0.499835  ################################</pre>

        <p>Chaque ligne présente un intervalle, le nombre de tokens
        (N.D.T. élément minimal pour le traitement, généralement un
        mot) avec le score dans cet intervalle, la moyenne de la
        probabilité de spam pour ces tokens, l'évaluation de la
        "spamicité" du message (pour les tokens de cet intervalle
        ou des précédents) et une barre correspondant au nombre de
        tokens.</p>

        <p>Dans l'histogramme ci-dessus, il y a beaucoup de tokens
        à faible score et à haut score. Ils s'équilibrent pour
        donner une "spamicité" de 0.500000</p>
      </li>

      <li>
        En utilisant "-vvv" on produit la liste de <em>tous</em>
        les tokens dans le message, avec de l'information pour
        chacun d'un. Par exemple: 
<pre>  X-Bogosity: No, tests=bogofilter, spamicity=0.500000
                        n    pgood     pbad      fw     U
  "which"              10  0.208333  0.000000  0.000041 +
  "own"                 7  0.145833  0.000000  0.000059 +
  "having"              6  0.125000  0.000000  0.000069 +
  ...
  "unsubscribe.asp"     2  0.000000  0.095238  0.999708 +
  "million"             4  0.000000  0.190476  0.999854 +
  "copy"                5  0.000000  0.238095  0.999883 +
  N_P_Q_S_s_x_md      138  0.00e+00  0.00e+00  5.00e-01
                           1.00e-03  4.15e-01  0.100</pre>
        Les colonnes affichées donnent les informations suivantes:

        <dl><dt>"&hellip;"</dt>

          <dd>le token pris en compte</dd>

          <dt>n</dt>

          <dd>Le nombre de fois ou le token a été rencontré lors de
          l'apprentissage</dd>

          <dt>pgood</dt>

          <dd>Proportion de bons messages (ham) contenant ce
          token</dd>

          <dt>pbad</dt>

          <dd>Proportion de mauvais messages (spam) contenant ce
          token</dd>

          <dt>fw</dt>

          <dd>L'index pondéré de Robinson, qui combine pgood et
          pbad pour donner une valeur qui sera proche de zéro si un
          message contenant ce token est vraisemblablement un ham,
          et proche de un s'il est vraisemblablement un spam.</dd>

          <dt>U</dt>

          <dd>'<b>+</b>' Si ce token contribue à la note finale,
          '<b>-</b>' sinon. Un token est exclu quand un score est à
          moins de "min_dev" de 0.5. min_dev est paramétrable.</dd>
        </dl>

        <p>La dernière ligne montre:</p>

        <ul style="margin-top:0;margin-bottom:1em;">
          <li>Les résultats cumulés des colonnes</li>

          <li>Les valeurs des paramètres de Robinson <b>s</b> et
          <b>x</b> et celle de <b>min_dev</b></li>
        </ul>
      </li>

      <li>
        Utiliser "-R" produit la sortie de "-vvv" décrite plus haut
        plus 2 colonnes supplémentaires:

        <dl><dt>invfwlog</dt>

	  <dd>le logarithme of fw</dd>

	  <dt>fwlog</dt>

	  <dd>le logarithme of (1-fw)</dd>

	</dl>

        <p>La sortie de "-R" est présentée pour être utilisé avec
        le langage R de calcul statistique. Plus d'information est
        disponible sur la page du projet R pour le calcul
        statistique <a href="http://www.r-project.org/">http://www.r-project.org/</a>.</p>
      </li>
    </ul>

    <hr>

    <h2 id="asian-spam">Comment traiter les spams asiatiques?</h2>

    <p>Beaucoup de personnes reçoivent du mail non sollicité
    utilisant des caractères asiatiques. Comme ils ne pratiquent
    pas la langue et qu'ils ne connaissent personne là bas, ils
    supposent qu'il s'agit de spam.</p>

    <p>La bonne nouvelle est que bogofilter les détecte de manière
    plutôt efficace. La mauvaise nouvelle est que cela peut être
    coûteux. Vous avez en gros trois possibilités:</p>

    <ul>
      <li>
        <p>Vous pouvez simplement laisser bogofilter gérer le
        problème. Entraînez le avec des messages asiatiques
        identifiés comme spam. Bogofilter analysera les messages du
        mieux qu'il peut et ajoutera des tokens à la liste des mots
        de spam. La liste des mots contiendra beaucoup de tokens
        qui n'auront pas de sens pour vous (puisque la table de
        caractères ne peut être affichée), mais Bogofilter peut
        travailler avec eux et identifier correctement du spam
        asiatique.</p>
      </li>

      <li>Une seconde méthode est d'utiliser l'option du fichier de
      configuration "replace_nonascii_characters". Ceci remplacera
      les caractères à code ASCII "haut" (ceux compris entre 0x80
      et 0xFF) avec des points d'interrogations '?'. Ceci permet de
      garder une base de petite taille. Malheureusement ceci entre
      en conflit avec les langues européennes qui contiennent
      beaucoup de voyelles et de consonnes accentuées à code ASCII
      "haut".</li>

      <li>Si vous êtes sûr de ne jamais recevoir un message
      légitime dans ces langues, vous pouvez directement les
      détruire. Cela diminuera la base d'autant. Vous pouvez le
      faire avec un script MDA.</li>

      <li>Ceci est un script qui effacera les messages écrits avec
      les tables de caractères asiatiques</li>

      <li>
	<pre>## Efface silencieusement tous les mails en langue asiatique
	UNREADABLE='[^?"]*big5|iso-2022-jp|ISO-2022-KR|euc-kr|gb2312|ks_c_5601-1987'
	:0:
	* 1^0 $ ^Subject:.*=\?($UNREADABLE)
	* 1^0 $ ^Content-Type:.*charset="?($UNREADABLE)
	spam-unreadable

	:0:
	* ^Content-Type:.*multipart
	* B?? $ ^Content-Type:.*^?.*charset="?($UNREADABLE)
	spam-unreadable</pre>

        <p>Avec un tel programme, Bogofilter ne verra <i>jamais</i>
        le message.</p>
      </li>
    </ul>

    <hr>

    <h2 id="query-database">Comment faire une requête manuelle sur
    la base?</h2>

    <p>Pour trouver le nombre de spam et ham pour un token (mot),
    utiliser l'option '-w' de bogoutil. Par exemple, "bogoutil -w
    $BOGOFILTER_DIR example.com" fournit le nombre de ham et spam
    pour "example.com".</p>

    <p>Si vous voulez le score de spamicité en plus du nombre de
    ham et spam pour un token, utilisez l'option '-p' de bogoutil.
    Par exemple, "bogoutil -p $BOGOFILTER_DIR example.com" fournit
    en plus des nombres ham et spam, le score du mot.</p>

    <p>Pour trouver combien de messages sont dans votre liste de
    mots, faites une requête sur le pseudo-token ".MSG_COUNT" (avec
    le point devant NdT). Par exemple, lancez la commande "bogoutil
    -w $BOGOFILTER_DIR .MSG_COUNT".</p>

    <p>Pour dire combien de tokens sont présents dans votre liste
    de mots, envoyez la sortie de la commande dump de bogoutil vers
    la commande "wc". Par exemple utilisez "bogoutil -d
    $BOGOFILTER_DIR/wordlist.db | wc -l " pour afficher le nombre d'apparitions
    des tokens (Si vous utilisez spamlist.db et goodlist.db, lancez la commande pour
    chacun d'eux).</p>

    <hr>

    <h2 id="rescue">Comment faire si ma liste de mots est
    corrompue?</h2>

    <p>Si vous pensez que vos listes de mots ont été dégradées,
    vous pouvez regarder ce qu'en dit BerkeleyDB en lançant:</p>
    <pre>	db_verify wordlist.db</pre>

    <p>S'il y a un problème, vous pouvez récupérer tout ou partie
    des tokens et leur nombre avec la commande suivante:</p>
    <pre>	bogoutil -d wordlist.db | bogoutil -l wordlist.db.new</pre>

    <p>ou avec</p>
    <pre>	db_dump -r wordlist.db &gt; wordlist.txt
    db_load wordlist.new &lt; wordlist.txt</pre>
<p>
Si vous utilisez deux listes de mots (spamlist.db et goodlist.db), lancez les mêmes commandes
pour chacun d'eux.
</p>

    <hr>

    <h2 id="nfs">Puis-je partager une liste de mots par NFS?</h2>

    <p>Si vous ne faites que les lire, il n'y a pas de problème.
    Si vous les mettez à jour, vous devrez fournir les bonnes options de verrouillage
    pour éviter la corruption des données. Quand vous compilerez
    Bogofilter, vous aurez besoin de vérifier que le script
    configure a positionné "#define HAVE_FCNTL 1" dans votre
    fichier config.h. Les systèmes d'exploitation UNIX supporteront
    quasiment tous ceci. Si vous utilisez une version exotique ou
    particulièrement ancienne, assurez-vous qu'elle supporte
    fcntl(). Si "#define HAVE_FCNTL 1" est positionné, ce qui indique
    que votre système connaît la fonction fcntl(), alors
    décommentez "#define HAVE_FLOCK 1" afin que le système de
    verrouillage utilise fcntl() au lieu du verrouillage flock().
    Si votre système ne supporte pas fcntl, alors vous ne pourrez
    partager les listes de mots en NFS sans risquer une corruption
    des données.</p>

    <p>Ensuite, assurez-vous que NFS est correctement configuré
    avec "lockd" en fonctionnement. Référez vous à la documentation
    NFS à propos du lancement de "lockd" ou de "rpc.lockd". La
    plupart des systèmes avec NFS l'active par défaut.</p>

    <hr>

    <h2 id="return-codes">Pourquoi Bogofilter fournit des codes de
    retour tels que 0 et 256 quand il est lancé à l'intérieur d'un
    programme?</h2>

    <p>Vraisemblablement les codes de retour ont été réécrits par
    waitpid(2). En C utilisez WEXITSTATUS(status) dans sys/wait.h, ou
    une macro comparable pour obtenir la valeur correcte. En Perl
    utilisez 'system("bogofilter $input")&gt;&gt; 8'. 
    Si vous voulez plus d'information, lancez la commande
    <code>"man waitpid"</code>.</p>
    <hr>

    <h2 id="changed-options">Pourquoi mes scripts échouent depuis
    que je suis passé en 0.11?</h2>

    <p>Avec la version 0.11, les options de Bogofilter pour
    enregistrer les ham ou les spam ont changé. Elles permettent
    désormais d'enregistrer (ou désenregistrer) les messages dans
    les listes de mots ham ou spam. Avant cette version, il était
    impossible de désenregistrer un message d'une liste sans
    l'enregistrer dans l'autre.</p>

    <p>Bogofilter fournit quatre options de classement -
    '-s', '-n', '-S', and '-N'. Avec la version 0.11, le sens de
    '-N' et '-S' a changé pour permettre le "déclassement" des
    messages. La définition des quatre options est la suivante:</p>

    <dl><dt>-s</dt>

       <dd>indique l'enregistrement du message comme spam.
       C'est-à-dire incrémenter le nombre de spam pour ce token.</dd>

       <dt>-n</dt>

       <dd>indique l'enregistrement du message comme ham. C'est à dire
       incrémenter le nombre de ham pour ce token.</dd>

       <dt>-S</dt>

       <dd>indique le désenregistrement du message des spams. C'est à
       dire décrémenter le nombre de spam pour ce token.</dd>

       <dt>-N</dt>

       <dd>indique le désenregistrement du messages des hams. C'est à
       dire décrémenter le nombre de ham pour cd token.</dd>

    </dl>

    <p>Avant la version 0.11, l'option '-S' était utilisée pour
    déplacer un message de la liste ham vers la liste spam. Il y
    avait deux actions. Maintenant, chacune des actions est appelée
    par sa propre option. Pour obtenir le même effet que l'ancien
    '-S', vous devez utiliser '-N -s' (ou '-Ns' qui est
    synonyme).</p>

    <p>De la même manière, l'ancienne option '-N' équivaut à
    '-Sn' (ou '-S -n').</p>

    <p>Les scripts MDA utilisent d'habitude '-s' et '-n' n'ont donc
    pas besoin de modification. Les autres scripts qui utilisaient
    '-S' et '-N' pour corriger les erreurs de classement
    <em>doivent</em> être changés.</p>

    <hr>
 	 
      <h2 id="changed-exitcodes">Pourquoi, depuis que j'ai installé la
      0.14, mes scripts ne fonctionnent-ils plus?</h2>
 	 
      <p>Bogofilter-0.14 introduit des codes de retour complémentaires pour
      prendre en compte la troisième classification des mails (spam, ham et
      unsure). Avant la 0.14, les codes de retour étaient 0 pour spam, 1 pour
      ham, et 2 pour les erreurs. Désormais c'est 0 pour spam, 1 pour ham, 2
      pour unsure et 3 pour toute erreur.</p>

   <hr>

      <h2 id="changed-tagging">Pourquoi, depuis que j'ai installé la
      0.15, Bogofilter fonctionne-t-il moins bien?</h2>
      <p>Avant la version 0.15.4, Bogofilter ajoutait des préfixes dédiés au marquage
      des en-têtes "Subject:", "From:", "To:" et "Return-Path". Depuis la version
      0.15.4, les lignes "Received:" sont aussi traitées spécifiquement et toutes les
      autres lignes d'en-têtes ont un préfixe "head:". Comme Bogofilter n'a pas
      rencontré précédemment de tels préfixes, les tokens ainsi constitués
      ne peuvent plus contribuer,
      temporairement, à l'évaluation ham ou spam. Cette perte d'information va dégrader les
      performances de Bogofilter.</p>
      <p>Il existe deux moyens de gérer ce problème. Le premier consiste à réentrainer
      Bogofilter avec tous vos anciens ham et spam. Cela créera les nouvelles entrées
      avec les entrées "head:" nécessaires, et tout sera correct.
      </p>
      <p>Le second moyen est d'utiliser la nouvelle option header-degen ("-H"). Quand il
      classe un message, header-degen indique à Bogofilter de regarder à la fois
      "head:token" et "token" dans la base. Les deux scores ham et spam sont combinés
      pour donner un résultat cumulatif de l'évaluation. Enregistrer de tels messages créera
      les entrées "head:token" dans la base. Après un mois environ d'utilisation du "-H",
      la base devrait contenir suffisamment d'entrées avec le préfixe "head:" et l'utilisation
      du "-H" ne sera plus nécessaire.</p>
      <hr>
      <h2 id="remove-spam-or-nonspam"> Avec une wordlist combinée, comment
          puis-je détruire tous les tokens spams (ou les non-spams) ?</h2>

      <p>Bogoutil vous permet de lister (dump) une wordlist et de charger les tokens dans
      une nouvelle wordlist. Avec l'aide d'outils tels que awk et grep, les nombres peuvent
      être mis à zéros et les tokens dont les comptes seraient à
      zéro pour les spams et les hams pourraient être détruits.</p>
   
      <p>Les commandes suivantes vont détruire les tokens des messages
      spams:</p>

      <pre>    bogoutil -d wordlist.db | \
       awk '{print $1 " " $2 " 0"}' | grep -v " 0 0" | \
       bogoutil -l wordlist.new.db
      </pre>
   
       <p>Les commandes suivantes vont détruire les tokens provenant des
       messages hams.</p>
   <pre>    bogoutil -d wordlist.db | \
       awk '{print $1 " 0 " $3}' | grep -v " 0 0" | \
       bogoutil -l wordlist.new.db
   </pre>
   

    <hr>

    <h2 id="port-notes">Comment faire fonctionner Bogofilter sur
    Solaris, BSD, etc.?</h2>

    <p>Si vous n'avez pas déjà la version 3.0 ou plus de la <a href="http://www.sleepycat.com/">BerkeleyDB</a>, alors <a href="http://www.sleepycat.com/download.html">téléchargez la</a>,
    décompactez la, et lancez les commandes suivantes dans le
    répertoire 'dist':</p>
    <pre>$ cd build_unix
	$ sh ../dist/configure
	$ make
	# make install</pre>

    <p>Puis, téléchargez la <a href="http://sourceforge.net/project/showfiles.php?group_id=62265">version
    portable</a> de Bogofilter.</p>

    <h3>Sur Solaris</h3>

    <p>Décompactez la, puis faites:</p>
    <pre>	$ ./configure --with-db=/usr/local/BerkeleyDB-4.1
	$ make
	# make install-strip</pre>

    <p>Vous pourrez alors, soit mettre un lien symbolique sur
    libdb.so dans /usr/lib, ou utiliser une version modifiée de la
    variable d'environnement LD_LIBRARY_PATH avant de lancer
    Bogofilter.</p>
    <pre>	$ LD_LIBRARY_PATH=/usr/lib:/usr/local/lib:/usr/local/BerkeleyDB-4.1</pre>

    <p>Notez que que certaines versions de make livrées avec
    Solaris bugguent quand vous essayez de compiler Bogofilter hors
    de son répertoire source. Soit vous compilez dans le répertoire
    source (comme suggéré ci-avant), soit vous utilisez GNU make
    (gmake).</p>

    <h3>Sur FreeBSD</h3>

    <p>Des paquetages existent avec des versions très récentes de
    Bogofilter. Cette approche utilisent les paquetages très
    recommandés portupgrade et cvsup. Pout installer ces deux
    magnifiques outils (vous n'avez besoin de le faire qu'une seule
    fois):</p>
    <pre>	# pkg_add -r portupgrade cvsup</pre>

    <p>Pour installer ou mettre à jour Bogofilter, il suffit de
    mettre à jour <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/cvsup.html">
    l'arbre de conversion (portstree) avec cvsup</a> puis de
    taper</p>
    <pre>	# portupgrade -N bogofilter</pre>

    <h3>Sur HP-UX</h3>

    <p>Regardez le fichier doc/programmer/README.hp-ux dans la
    distribution des sources.</p>

    <!--
    $Id$
    -->
  </body></html>
