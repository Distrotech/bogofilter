<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
    <title>FAQ Bogofilter</title>
    <style type="text/css">
      h2 {
	margin-top: 1em;
	font-size: 125%;
      }
      h3 {
	margin-top: 1em;
	font-size: 110%;
      }
      p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
      }
      ul {
	margin-top: 1.5em;
	margin-bottom: 0.5em;
      }
      ul ul {
	margin-top: 0.25em;
	margin-bottom: 0;
      }
      li {
	margin-top: 0;
	margin-bottom: 1em;
      }
      li li {
	margin-bottom: 0.25em;
      }
      dt {
	margin-top: 0.5em;
	margin-bottom: 0;
      }
      hr {
	margin-top: 1em;
	margin-bottom: 1em;
      }
    </style>
  </head>

  <body>
     <h1>FAQ Bogofilter</h1>

     <p>Versions Officielles: en
     <a href="http://bogofilter.sourceforge.net/faq.shtml">Anglais</a> or
     <a href="http://bogofilter.sourceforge.net/faq_fr.shtml">Français</a><br>

     Mainteneur: David Relson &lt;relson@osagesoftware.com&gt;<br>
     Traducteur: Fabrice Prigent &lt;Fabrice.Prigent@univ-tlse1.fr&gt;</p>

    <p>Ce document a pour but de répondre aux questions fréquemment
    posées sur Bogofilter.</p>

    <ul>
      <li>
        Information générale
        <ul>
          <li><a href="#what-is-bogofilter">Qu'est ce que Bogofilter?</a></li>
          <li><a href="#bogo-what">Bogo-quoi?</a></li>
          <li><a href="#bogo-how">Comment fonctionne Bogofilter ?</a></li>	  
          <li><a href="#lists">Listes de diffusion Bogofilter</a></li>
        </ul>
      </li>

      <li>
        Questions opérationnelles
        <ul>
          <li><a href="#training">Comment débuter l'apprentissage de Bogofilter?</a></li>
          <li><a href="#production">Comment conserver une bonne d'acuité?</a></li>
	  <li><a href="#mboxformats">Quels formats de boites aux lettres (fichier) Bogofilter comprend-il?</a></li>
          <li><a href="#vvv">Que signifie la sortie verbeuse de Bogofilter?</a></li>
          <li><a href="#unsure">Qu'est-ce que le mode <i>Unsure</i>?</a></li>
	  <li><a href="#train-on-error">Qu'est-ce que "l'entrainement sur erreur" et
	  "l'entrainement sur épuisement"?</a></li>
          <li><a href="#autoupdate">A quoi sert l'option '-u' (autoupdate) ?</a></li>
          <li><a href="#spamassassin">Comment puis-je utiliser SpamAssassin pour entraîner Bogofilter?</a></li>
          <li><a href="#asian-spam">Comment traiter les spams asiatiques?</a></li>
        </ul>
      </li>

      <li>
        Questions sur les bases de données
        <ul>
          <li><a href="#query-database">Comment faire une requête manuelle sur la base de données?</a></li>
          <li><a href="#page-notfound">Comment se fait-il que parfois j'obtienne le message DB_PAGE_NOTFOUND ?</a></li>
          <li><a href="#rescue">Comment faire si ma base de mots est corrompue?</a></li>
          <li><a href="#update">Comment puis-je transformer les bases de mots dans le
	  nouveau format combiné ?</a></li>
          <li><a href="#multiple">Puis-je utiliser plusieurs bases de mots?</a></li>
          <li><a href="#ignore">Puis-je dire à Bogofilter d'ignorer certains tokens?</a></li>
	  </ul>
      </li>

      <li>
        Problèmes techniques
	<ul>
          <li><a href="#nfs">Puis-je partager une liste de mots par NFS?</a></li>
          <li><a href="#return-codes">Pourquoi Bogofilter retourne les codes erreurs tels que 0 et
	  256 quand il est appelé par un programme?</a></li>
          <li><a href="#changed-options">Pourquoi, depuis que j'ai mis à jour, mes scripts ne fonctionnent plus?</a></li>
          <li><a href="#changed-tagging">Pourquoi, depuis que j'ai mis à jour, Bogofilter fonctionne-t-il moins bien?</a></li>	  
	  <li><a href="#remove-spam-or-nonspam"> Comment puis-je détruire tous les tokens spam ?</a></li>
        </ul>
      </li>

      <li>
        Problèmes de portabilité
        <ul>
          <li><a href="#port-notes">Comment puis-je faire fonctionner Bogofilter sur Solaris, BSD, etc.?</a></li>
          <li><a href="#make-notes">Puis-je utiliser la commande make sur mon système d'exploitation?</a></li>
          <li><a href="#build">Comment dois-je compiler Bogofilter pour fonctionner avec
	  un utilisateur non root, ou avec un préfixe d'installation non standard ?</a></li>
          <li><a href="#patch">Comment dois-je compiler Bogofilter avec les patches?</a></li>
          <li><a href="#smaller">Comment puis-je créer des executables plus petits?</a></li>
        </ul>
      </li>
    </ul>

    <hr>

    <h2 id="what-is-bogofilter">Qu'est ce que Bogofilter?</h2>

    <p>Bogofilter est un filtre bayésien rapide basé sur les travaux de
    <a href="http://www.paulgraham.com/">Paul Graham</a>
    dans son article <a href="http://www.paulgraham.com/spam.html">Un plan contre le
    Spam</a>. Bogofilter utilise l'algorithme de moyenne géométrique de
    <a href="http://radio.weblogs.com/0101454/stories/2002/09/16/spamDetection.html">
    Gary Robinson</a> avec la <a href="http://www.linuxjournal.com/article.php?sid=6467">méthode modifiée de Fisher (khi2)</a>
    pour classifier les spams et hams (N.D.T.: les mails autres que
    des spams).</p>

    <p>La page web de <a href="http://bogofilter.sourceforge.net/">Bogofilter</a> chez
    SourceForge est le point central pour toutes les ressources sur
    Bogofilter.</p>

    <p>Bogofilter a été créé par <a href="http://catb.org/%7Eesr/">Eric
    S. Raymond</a> le 19 Août 2002.  Il a gagné en popularité depuis
    Septembre 2002, et un grand nombre de programmeurs ont commencé à
    participer au projet.</p>

    <p>Le fichier <a href="http://bogofilter.sourceforge.net/NEWS">NEWS</a> décrit
    l'historique des versions de Bogofilter.</p>

    <hr>

    <h2 id="bogo-what">Bogo-quoi?</h2>

    <p>Bogofilter est une sorte de bogomètre 
    <a href="http://www.catb.org/%7Eesr/jargon/html/B/bogometer.html">(bogometer)</a>
    ou filtre à bogues 
    <a href="http://www.catb.org/%7Eesr/jargon/html/B/bogon-filter.html">(bogon-filter)</a>,
    c'est à dire qu'il essaie d'identifier des mails bogués 
    <a href="http://www.catb.org/%7Eesr/jargon/html/B/bogus.html">(bogus)</a>
    en mesurant leur bogosité 
    <a href="http://www.catb.org/%7Eesr/jargon/html/B/bogosity.html">(bogosity)</a>.</p>

    <hr>
    <h2 id="bogo-how">Comment fonctionne Bogofilter ?</h2>

    <p>Jetez d'abord un oeil sur la section
    <a href="http://bogofilter.sourceforge.net/man_page.shtml#theory">THEORY OF OPERATION</a> du manuel
    pour une introduction. La principale source pour
    comprendre est l'article de Gary Robinson dans le Linux Journal
    <a href="http://www.linuxjournal.com/article.php?sid=6467">"A Statistical Approach to the Spam Problem"</a>
    (Une approche statistique du problème du Spam).</p>

    <p>Après avoir lu tout ceci, vous vous posez probablement quelques questions.
    La première pourrait être "Bogofilter est-il réellement un filtre anti-spam bayésien ?" 
    Bogofilter est basé sur le théorème de Bayes et l'utilise dans les premières parties
    du calcul, puis d'autres méthodes statistiques par la suite. On peut donc affirmer sans risque
    qu'il s'agit d'un filtre anti-spam statistique avec un parfum bayésien.
    </p>

    <p>D'autres questions qui pourraient vous assaillir concerneraient les prérequis ou
    hypothèses de la théorie de Bayes. Les réponses simples sont : "Non, ils ne sont
    pas remplis" et "On s'en moque tant que cela marche". Une réponse plus élaborée
    mentionnerait que le postulat de base qui dit que "Un email est une collection
    aléatoire de mots, totalement indépendants les uns des autres" est violé. Il y a
    plusieurs points où la pratique prend des libertés avec la théorie. Certains
    sont tout le temps présents, d'autres dépendent de la manière dont vous
    utilisez Bogofilter :</p>

    <ul>
    <li>Les mots dans un e-mail ne sont en aucun cas indépendants. Dans toutes les langues
    c'est même le contraire qui prime.</li>
    <li>Les mots utilisés ne sont pas aléatoires, même si certains spammeurs utilisent
    des mots aléatoires.</li>
    <li>L'entrainement complet, ou utilisant un échantillon aléatoire, suit les principes
    de Bayes. Choisir les messages pour l'entrainement viole le postulat disant que les messages
    utilisés pour l'entrainement sont un échantillon aléatoire des messages reçus. Ce
    principe est aussi violé par la fonction auto-update de Bogofilter (avec le paramètre
    tresh_update), <a href="#train-on-error">l'entrainement sur erreur</a>, ou n'importe
    quelle approche similaire.</li>
    <li>La même chose s'applique si vous utilisez le même message plus d'une fois.</li>
    <li>D'autres problèmes peuvent être soulevés par le fait de modifier la base de données
    en enlevant les tokens (en utilisant par exemple bogoutil avec -a ou -c).</li>
    <li>Il y en a certainement d'autres.</li>
    </ul>

    <p>Comme la page manuel l'explique, Bogofilter essaie de composer avec l'influence
    négative de ces hypothèses non respectées. Certains disent que "ces écarts de la
    réalité travaillent en général en notre faveur" (Article de Gary).
    D'autres disent que, même dans ce cas, nous devrions ne pas trop nous écarter des hypothèses de base.
     En fait, ersonne ne sait <em>réellement</em>. Gardez simplement à l'esprit que
    si vous "chargez la mule", des problèmes se poseront. La clé de l'approche de
    Bogofilter est : la chose qui importe le plus est que cela fonctionne dans le
    monde réel.</p>

    <p>Maintenant que vous avez été prévenus, amusez vous et utilisez Bogofilter
    au mieux de vos besoins.</p>

    <h2 id="lists">Listes de diffusion</h2>

    <p>Il existe actuellement 4 listes de diffusion pour
    Bogofilter (en anglais):</p>

    <table border="1" width="100%">
      <tbody><tr>
          <th>Adresses des listes</th>
          <th>Liens</th>
          <th>Description</th>
        </tr>

        <tr>
          <td>bogofilter-announce@bogofilter.org</td>
	  <td><a href="http://www.bogofilter.org/mailman/listinfo/bogofilter-announce">[subscribe]</a>
	  [archives: <a
	  href="http://www.bogofilter.org/pipermail/bogofilter-announce">mailman</a>, <a
	  href="http://news.gmane.org/thread.php?group=gmane.mail.bogofilter.announce">gmane</a>]
	  </td>
          <td>Une liste où sont annoncées les nouvelles versions.</td>
        </tr>

        <tr>
          <td>bogofilter@bogofilter.org</td>
	  <td><a href="http://www.bogofilter.org/mailman/listinfo/bogofi[lter">[subscribe]</a>
	  [archives: <a
	  href="http://www.bogofilter.org/pipermail/bogofilter">mailman</a>, <a
	  href="http://news.gmane.org/thread.php?group=gmane.mail.bogofilter.general">gmane</a>]
	  </td>
          <td>Une liste de diffusion généraliste sur Bogofilter.</td>
        </tr>

        <tr>
          <td>bogofilter-dev@bogofilter.org</td>
	  <td><a href="http://www.bogofilter.org/mailman/listinfo/bogofilter-dev">[subscribe]</a>
	  [archives: <a
	  href="http://www.bogofilter.org/pipermail/bogofilter-dev">mailman</a>, <a
	  href="http://news.gmane.org/thread.php?group=gmane.mail.bogofilter.devel">gmane</a>]
	  </td>
          <td>Une liste pour des échanges de patches, le
          développement, et les discussions techniques.</td>
        </tr>

        <tr>
          <td>bogofilter-cvs@lists.sourceforge.net</td>
          <td><a href="http://lists.sourceforge.net/mailman/listinfo/bogofilter-cvs">[abonnement]</a>
	  <a href="http://sourceforge.net/mailarchive/forum.php?forum=bogofilter-cvs">[archive]</a></td>
          <td>Une liste pour annoncer les changements de code sur
          l'archive CVS.</td>
        </tr>
      </tbody>
    </table>

    <hr>
    <h2 id="training">Comment débuter l'apprentissage de Bogofilter?</h2>
    <p>Pour classifier les messages comme ham ou spam, Bogofilter
    a besoin d'apprendre votre courrier. Pour commencer, le mieux est d'avoir
    un corpus (aussi large que possible) de messages dont vous êtes sûr de
    l'état de ham ou de spam. (Des erreurs à ce stade occasionneront des problèmes plus tard,
    aussi, soyez attentifs <code>;-)</code>). Attention, n'utilisez que votre email. L'utilisation d'autres
    corpus (tel qu'un corpus trouvé sur Internet), peut pousser
    Bogofilter à tirer de mauvaises conclusions après tout, votre but est de lui
    faire comprendre <em>votre</em> courrier.</p>
    
    <p>Une fois que vous avez vos corpus de spam et de ham, vous avez quatre
    choix possibles. Dans tous les cas, cela fonctionnera mieux si votre base
    d'apprentissage (les corpus ci-dessus) est conséquente. Plus un corpus est
    petit, plus grand sera le nombre d'erreurs que fera Bogofilter en production. Supposons
    que vos corpus se trouvent dans deux fichiers mbox: ham.mbx et spam.mbx.</p>

    <ul>
    <li><p>Méthode 1) Entrainement complet: Entraînez Bogofilter avec tous vos messages. Dans notre
    example:</p>
    <pre>    bogofilter -s &lt; spam.mbx
    bogofilter -n &lt; ham.mbx</pre></li>
    </ul>
    <p>Note: Le répertoire contrib de Bogofilter contient deux scripts qui tous les deux utilisent une
    technique d'entrainement sur erreur. Cette technique évalue chaque message et n'ajoute à la
    base de données que les messages qui ont été mal évalués (messages marqués comme incertains, ham
    évalués en tant que spam ou inversement). Le but est de créer une base de données des mots réellement
    <em>nécessaires</em> pour classer correctement les messages. La base de données résultante est plus
    petite que celle de l'entrainement complet.</p>
    <ul>

    <li><p>Méthode 2) Utilisez le script  bogominitrain.pl (dans le répertoire contrib).
    Il évalue les messages le même ordre que vos fichiers mailbox. Vous devriez utiliser
    l'option -f qui va demander au script de répéter le travail, jusqu'à ce que tous
    les messages soient classés correctement.
    (Si nécessaire, vous pouvez même ajuster le niveau de certitude). Comme le script s'assure
    que la base de données
    connaît "tout" votre corpus d'entrainement (avec la précision de votre choix), cela
    fonctionne très bien. Vous pouvez utiliser <code>-o</code> pour créer une marge de
    sécurité autour de "spam_cutoff" 
    Avec spam_cutoff=0.6 vous voudrez peut-être évaluer tous les hams
    dans votre corpus en dessous de 0.3 et tous les spams au delà de 0.9. Notre exemple devient:</p>

    <pre>    bogominitrain.pl -fnv ~/.bogofilter ham.mbx spam.mbx '-o 0.9,0.3'</pre></li> 

    <li><p>Méthode 3) Utilisez le script randomtrain (dans le répertoire contrib).
    Le script génère une liste de tous les messages dans les mailbox, mélange la liste, puis
    évalue chaque message, suiv d'un entrainement si nécessaire. Dans notre exemple:</p>

    <pre>     randomtrain -s spam.mbx -n ham.mbx </pre>
    
    <p>Comme pour la méthode 4, cela fonctionne mieux si vous commencer avec un corpus
    d'entrainement de plusieurs milliers de messages. Ceci vous donnera une base de données
    plus complète et significativement plus grande.</p></li>

    <li><p>Méthode 4)  Si vous avez suffisamment de spam et de ham dans votre corpus, "réservez"
    10000 spams et 10000 hams dans des fichiers mbox séparés, puis utilisez ce corpus pour
    l'entraînement. Lancez alors Bogofilter pour classer les spams et hams restants. Prenez tout message
    incorrectement évalué ou ayant le statut incertain, et utilisez les pour un nouvel apprentissage. Cette méthode
    donne la meilleure méthode possible de discrimination. Voici deux petits scripts qui peuvent
    être utilisés pour classifier les messages "mauvais élèves".</p>
    <pre> 	#! /bin/sh
	#  class3 -- classe un message en mauvais, bon ou incertain
	cat &gt;msg.$$
	bogofilter $* &lt;msg.$$
	res=$?
	if [ $res = 0 ]; then
	    cat msg.$$ &gt;&gt;corpus.bad
	elif [ $res = 1 ]; then
	    cat msg.$$ &gt;&gt;corpus.good
	elif [ $res = 2 ]; then
	    cat msg.$$ &gt;&gt;corpus.unsure
	fi
	rm msg.$$</pre>

     <pre>	#! /bin/sh
	# classify -- Place tous les messages dans un fichier mbox à l'aide de class3
	src=$1;
	shift
	formail -s class3 $* &lt;$src</pre>

    <p>Dans notre exemple (après l'entrainement initial):</p>

    <pre>	classify spam.mbx [bogofilter options]
        bogofilter -s &lt; corpus.good
        rm -f corpus.*
        classify ham.mbx [bogofilter options]
        bogofilter -n &lt; corpus.bad
	rm -f corpus.*</pre></li>
    </ul>
    <h3>Comparaison de ces méthodes</h3>
    <p>Il est important de comprendre les conséquences des méthodes que
    nous venons de décrire. Faire un entrainement complet, tel que dans les
    méthodes 1 et 4 produit une base de données plus grande que ne le
    ferait un entrainement avec les méthodes 2 ou 3. Si votre base de données
    doit être de petite taille (par exemple à cause de quotas), utilisez les
    méthodes 2 ou 3.</p>
    <p>L'entrainement avec la méthode 1 est le plus rapide. L'entrainement sur erreur
    (tel que décrit dans les méthodes 2,3 et 4) est efficace, mais
    l'apprentissage est plutôt lent.</p>

    <hr>
 
    <h2 id="production">Comment puis-je conserver une bonne acuité ?</h2>
    <p>Bogofilter fera des erreurs de temps en temps. C'est pourquoi un
    apprentissage régulier est important. Il existe principalement deux méthodes pour le faire.
    Premièrement, vous pouvez l'entraîner avec chaque nouveau message (en utilisant l'option
    -u). Deuxièmement, vous pouvez ne l'entraîner que sur des erreurs.</p>
    
    <p>De plus, vous pouvez reconstruire votre base à certains moments,
    par exemple quand une nouvelle fonctionnalité importante est ajoutée à Bogofilter.
    Il peut être alors fort utile de mettre à jour régulièrement votre corpus d'apprentissage.</p>
    
    <p>Bogofilter fait toujours de son mieux avec les informations
    disponibles. Cependant, il fera des erreurs, tel que classer des ham en spam
    (faux positifs) ou spam en ham (faux négatifs). Pour réduire la probabilité d'un réapparition
    de l'erreur, il sera nécessaire d'entrainer Bogofilter avec le message erroné. Si un message est
    classé incorrectement spam, utilisez l'option <code>-n</code> pour l'intégrer en tant que ham.
    Utilisez l'option <code>-s</code> pour l'intégrer en tant que spam.</p>

    <p>Bogofilter a une option <code>-u</code> qui, automagiquement, met à jour la liste des mots
    après chaque évaluation de messages. Comme Bogofilter fait parfois des erreurs, cette méthode a
    l'inconvénient de dégrader la base d'entrainement avec des entrées erronées. Vous aurez alors
    besoin de la regarder et la corriger fréquemment.
    La correction peut être faite en utilisant <code>-Sn</code> pour changer la classification du message
    de spam en ham et <code>-Ns</code> pour changer de ham en spam.
    
    </p><p>Corriger un message incorrectement classé peut affecter la classification d'autres
    messages. Plus votre base de données sera petite, plus grande sera la probabilité qu'une
    erreur d'apprentissage créee des classifications incorrectes.</p>
    
    <p>L'utilisation de la méthode 2 ou 3 (ci-dessus) peut compenser cet effet.
    Repéter l'entrainement avec le corpus complet (y compris les messages de corrections ajoutés
    depuis le précédent apprentissage). Ceci ajoutera des messages dans la base de données afin
    que d'atteindre un nouvel équilibre, annulant les effets éventuellement de "surcompensation".</p>

    <p>Une stratégie alternative, basée sur la méthode 4 de
    la section précédente est la suivante: Périodiquement, prenez des blocs de messages et utilisez les
    scripts de la méthode 4 pour les classer. Analyser manuellement les spams, ham et incertains, corriger
    les erreurs, puis séparer les incertains en hams et spam. Jusqu'à ce que vous ayez 10000 spams et 10000 hams
    dans votre base d'apprentissage, entraînez avec les hams, les spams, puis les erreurs et enfin les incertains.
    Plus tard, vous n'entrainerez qu'avec les erreurs et les incertains, en ignorant les messagess que Bogofilter
    a correctement classé.
    </p>

    <p>Notez que vous devrez régulièrement lancer:</p>

    <pre>    bogoutil -d wordlist.db | bogoutil -l wordlist.db.new
    mv wordlist.db wordlist.db.prv
    mv wordlist.db.new wordlist.db</pre>
    <p>ou pour les fichiers spamlist.db et goodlist.db (si vous utilisez Bogofilter avec
    les listes de mots séparés). Ceci compressera les bases de données pour n'occuper que le
    minimum d'espace disque nécessaire.
    </p>

    <hr>

    <h2 id="mboxformats">Quels formats de fichier Bogofilter
	comprend-il?</h2>

    <p>Bogofilter comprend les formats mbox traditionnel, Maildir et MH.
    Bogofilter ne soutient pas des sous-répertoires, vous devrez
    explicitement les lister si vous avez des répertoires Maildir++ ou
    MH - mentionnez seulement les noms absoluts des
    sous-répertoires.</p>

    <p>Pour des formats non soutenus, vous devrez transformer le fichier
    en un format que Bogofilter comprend. Mbox est souvent commode parce
    qu'il peut être enovyé directement à bogofilter.</p>

    <p>La liste suivante pourrait vous aider:</p>
    <dl><dt>format UW-IMAP/PINE mbx</dt><dd>convertir en mbox: <kbd>mailtool copy /full/path/to/mail.mbx
	    '#driver.unix//full/path/to/mbox'</kbd></dd></dl>

    <hr>

    <h2 id="vvv">Quelle est la signification de la sortie verbeuse
    de Bogofilter?</h2>

    <p>On peut dire à Bogofilter d'afficher des informations sur
    l'évaluation d'un message en le lançant avec les paramètres
    "-v", "-vv", "-vvv", or "-R".</p>

    <ul>
      <li>
        En utilisant "-v", Bogofilter génère la ligne d'entête
        "X-Bogosity:", par exemple
	<pre>  X-Bogosity: Ham, tests=bogofilter, spamicity=0.500000</pre></li>

      <li>
        En utilisant "-vv" Bogofilter génère un histogramme, par
        exemple 
<pre>  X-Bogosity: Ham, tests=bogofilter, spamicity=0.500000
          int  cnt    prob   spamicity  histogram
         0.00   29  0.000209  0.000052  #############################
         0.10    2  0.179065  0.003425  ##
         0.20    2  0.276880  0.008870  ##
         0.30   18  0.363295  0.069245  ##################
         0.40    0  0.000000  0.069245
         0.50    0  0.000000  0.069245
         0.60   37  0.667823  0.257307  #####################################
         0.70    5  0.767436  0.278892  #####
         0.80   13  0.836789  0.334980  #############
         0.90   32  0.984903  0.499835  ################################</pre>

        <p>Chaque ligne présente un intervalle, le nombre de tokens
        (N.D.T. élément minimal pour le traitement, généralement un
        mot) avec le score dans cet intervalle, la moyenne de la
        probabilité de spam pour ces tokens, l'évaluation de la
        "spamicité" du message (pour les tokens de cet intervalle
        ou des précédents) et une barre correspondant au nombre de
        tokens.</p>

        <p>Dans l'histogramme ci-dessus, il y a beaucoup de tokens
        à faible score et à haut score. Ils s'équilibrent pour
        donner une "spamicité" de 0.500000</p>
      </li>

      <li>
        En utilisant "-vvv" on produit la liste de <em>tous</em>
        les tokens dans le message, avec de l'information pour
        chacun d'un. Par exemple: 
<pre>  X-Bogosity: Ham, tests=bogofilter, spamicity=0.500000
                        n    pgood     pbad      fw     U
  "which"              10  0.208333  0.000000  0.000041 +
  "own"                 7  0.145833  0.000000  0.000059 +
  "having"              6  0.125000  0.000000  0.000069 +
  ...
  "unsubscribe.asp"     2  0.000000  0.095238  0.999708 +
  "million"             4  0.000000  0.190476  0.999854 +
  "copy"                5  0.000000  0.238095  0.999883 +
  N_P_Q_S_s_x_md      138  0.00e+00  0.00e+00  5.00e-01
                           1.00e-03  4.15e-01  0.100</pre>
        Les colonnes affichées donnent les informations suivantes:

        <dl><dt>"&#8230;"</dt><dd>le token pris en compte</dd><dt>n</dt><dd>Le nombre de fois ou le token a été rencontré lors de
          l'apprentissage</dd><dt>pgood</dt><dd>Proportion de bons messages (ham) contenant ce
          token</dd><dt>pbad</dt><dd>Proportion de mauvais messages (spam) contenant ce
          token</dd><dt>fw</dt><dd>L'index pondéré de Robinson, qui combine pgood et
          pbad pour donner une valeur qui sera proche de zéro si un
          message contenant ce token est vraisemblablement un ham,
          et proche de un s'il est vraisemblablement un spam.</dd><dt>U</dt><dd>'<b>+</b>' Si ce token contribue à la note finale,
          '<b>-</b>' sinon. Un token est exclu quand un score est à
          moins de "min_dev" de 0.5. min_dev est paramétrable.</dd></dl>

        <p>La dernière ligne montre:</p>

        <ul style="margin-top: 0pt; margin-bottom: 1em;">
          <li>Les résultats cumulés des colonnes</li>

          <li>Les valeurs des paramètres de Robinson <b>s</b> et
          <b>x</b> et celle de <b>min_dev</b></li>
        </ul>
      </li>

      <li>
        Utiliser "-R" produit la sortie de "-vvv" décrite plus haut
        plus 2 colonnes supplémentaires:

        <dl><dt>invfwlog</dt><dd>le logarithme of fw</dd><dt>fwlog</dt><dd>le logarithme of (1-fw)</dd></dl>

        <p>La sortie de "-R" est présentée pour être utilisé avec
        le langage R de calcul statistique. Plus d'information est
        disponible sur la page du projet R pour le calcul
        statistique <a href="http://www.r-project.org/">http://www.r-project.org/</a>.</p>
      </li>
    </ul>

    <hr>

    <h2 id="unsure">Qu'est-ce que le mode <i>Unsure</i> ?</h2>

    <p>La configuration par défaut de Bogofilter classera un message en
    tant que spam ou non-spam. Le paramètre SPAM_CUTOFF est utilisé pour cela.
    Les messages avec un score supérieur ou égal à SPAM_CUTOFF sont classés en
    spam. Les autres en ham.</p>

    <p>Il y a aussi un paramètre HAM_CUTOFF. Quand il est utilisé, les
    messages doivent avoir un score inférieur ou égal à HAM_CUTOFF pour
    être classés ham. Les messages avec un score compris entre HAM_CUTOFF et
    SPAM_CUTOFF sont étiquetés "unsure". Si vous regardez le fichier bogofilter.cf,
    vous verrez les lignes suivantes :</p>

    <pre>	#### CUTOFF Values
	#
	#	both ham_cutoff and spam_cutoff are allowed.
	#	setting ham_cutoff to a non-zero value will
	#	enable tri-state results (Spam/Ham/Unsure).
	#
	#ham_cutoff  = 0.45
	#spam_cutoff = 0.99
	#
	#	for two-state classification:
	#
	## ham_cutoff = 0.00
	## spam_cutoff= 0.99</pre>

    <p>Pour activer la classification Yes/No/Unsure, enlevez les dièses devant les
    deux dernières lignes.</p>

    <p>Alternativement, si vous préférez utiliser les labels Spam/Ham/Unsure
    au lieu de Yes/No/Unsure, enlevez les dièses devant la ligne :

    <pre>	## spamicity_tags = Yes, No, Unsure</pre>

    <p>Une fois que cela est fait, vous pourrez inclure les règles de filtrage
    suivantes pour votre outil de messagerie:</p>

    <pre>	if header contains "X-Bogosity: Spam", put in Spam folder
	if header contains "X-Bogosity: Unsure", put in Unsure folder</pre>

    <p>De plus, bogofilter.cf possède des directives pour modifier
    la ligne Sujet:, par exemple.</p>

    <pre>	#### SPAM_SUBJECT_TAG
	#
	#	tag added to "Subject: " line for identifying spam or unsure
	#	default is to add nothing.
	#
	##spam_subject_tag=***SPAM***
	##unsure_subject_tag=???UNSURE???</pre>

    <p>Avec de tels marqueurs, les règles de filtrage ressembleraient à ceci:</p>

    <pre>	if subject contains "***SPAM***", put in Spam folder
	if subject contains "???UNSURE???", put in Unsure folder</pre>

    <hr>

    <h2 id="train-on-error">Qu'est-ce que "l'entrainement sur erreur" et "l'entrainement sur épuisement"?</h2>

    <p>"L'entrainement sur erreur" implique l'analyse d'un corpus de messages dont le statut de spam ou ham
    est connu. Seuls ceux qui sont mal classés, ou dont le classement est incertain, seront intégrés dans
    la base de données d'apprentissage. Il a été montré que la sélection des seuls messages "mauvais élèves" était
    un moyen efficace d'entrainement. Si l'on entrainait Bogofilter avec tous les messages, il va
    réapprendre avec des spams ou hams évidents.</p>

    <p> Cette méthode peut être améliorée en utilisant une "marge de
    sécurité". En augmentant la valeur "spam cutoff" et en diminuant la valeur "ham cutoff",
    les messages qui sont proches du seuil seront utilisés, pour l'entrainement. L'utilisation de
    cette marge de sécurité a montré son efficacité à améliorer les
    résultats dans l'entrainement sur erreur. En général, des marges plus larges sont
    une aide supplémentaire (malgré le fait que des marges trop grandes ne soient
    pas optimales). Pour un mode à triple état, vous pouvez utiliser le milieu de 
    l'état unsure avec un intervalle de +/- 0.3 pour l'entrainement</p>

    <p>Répéter l'entrainement sur erreur sur le même corpus de message peut améliorer
    la précision. L'idée est que les messages qui ont été bien classés une première fois
    peuvent, à la suite de l'entrainement, être mal classés. Fait qui sera compensé par
    cette répétition.</p>
    
    <p>"L'entrainement sur épuisement" est la répétition de l'entrainement sur erreur, avec le même corpus
    de messages, jusqu'à ce que plus aucune erreur ne subsiste. Cette méthode peut
    aussi être améliorée grâce aux marges de sécurité. Voir pour cela
    
    <a href="http://www.garyrobinson.net/2004/02/spam_filtering_.html">L'article de Gary Robinson</a>
    pour plus de détail.</p>

    <p>
    Note: <code>bogominitrain.pl</code> possède une option <code>-f</code> qui permet de réaliser
    "l'entrainement sur épuisement". Si
    vous choisissez de l'utiliser, soyez conscient des effets secondaires possibles. L'utilisation
    de <code>-fn</code> évite de répéter l'entrainement pour chaque message.</p>

    <hr>

    <h2 id="autoupdate">Que fait l'option '-u' (autoupdate) ?</h2>

    <p>L'option '-u' (autoupdate) est utilisé pour compléter automatiquement
    la liste de mots. Quand cette option est utilisée et que Bogofilter classe
    un message en Spam ou Ham, les tokens du message sont ajoutés dans la
    liste de mots avec un marqueur ham ou spam (suivi le contexte).</p>

    <p>Prenons le cas de l'arrivée d'un nouveau message "Refinance now -
    best Mortgage rates". Il contient des mots que Bogofilter a déjà vu et, probablement,
    des nouveaux. En utilisant '-u' ces nouveaux mots seront
    ajoutés dans la liste des mots, afin que Bogofilter puisse mieux reconnaître
    les messages suivants qui lui ressembleraient.</p>

    <p>Si vous utilisez '-u', vous avez besoin de regarder attentivement les
    erreurs de classification et de réentrainer Bogofilter avec les messages
    qu'il a mal identifiés. Un message incorrectement classé et qui est auto-appris
    _peut_ amplifier les futures mauvaises classifications de Bogofilter. C'est
    le même problème que si vous, administrateur système, vous enregistriez mal
    un message : ham en spam ou vice versa.</p>
    
    <hr>

    <hr>

    <h2 id="spamassassin">Comment puis-je utiliser SpamAssassin
    pour l'apprentissage de Bogofilter?</h2>

    <p>Si vous avez un SpamAssassin actif (ou si vous voulez en
    créer un), vous pouvez utiliser ses codes de retour pour
    l'apprentissage de Bogofilter. Le moyen le plus simple est de
    créer un script pour votre MDA qui fait tourner SpamAssassin,
    tester l'état du code de retour spam/ham, et lancer Bogofilter
    pour valider le message. Le script procmail ci-dessous est un
    moyen de le faire:</p>
    <pre>	BOGOFILTER     = "/usr/bin/bogofilter"
	BOGOFILTER_DIR = "training"
	SPAMASSASSIN  = "/usr/bin/spamassassin"

	:0 HBc
	* ? $SPAMASSASSIN -e
	#spam yields non-zero
	#non-spam yields zero
	| $BOGOFILTER -n -d $BOGOFILTER_DIR
	#else (E)
	:0Ec
	| $BOGOFILTER -s -d $BOGOFILTER_DIR

	:0fw
	| $BOGOFILTER -p -e

	:0:
	* ^X-Bogosity:.Yes
	spam

	:0:
	* ^X-Bogosity:.No
	non-spam</pre>
  
    <hr>

    <h2 id="asian-spam">Comment traiter les spams asiatiques?</h2>

    <p>Beaucoup de personnes reçoivent du mail non sollicité
    utilisant des caractères asiatiques. Comme ils ne pratiquent
    pas la langue et qu'ils ne connaissent personne là bas, ils
    supposent qu'il s'agit de spam.</p>

    <p>La bonne nouvelle est que bogofilter les détecte de manière
    plutôt efficace. La mauvaise nouvelle est que cela peut être
    coûteux. Vous avez en gros trois possibilités:</p>

    <ul>
      <li>
        <p>Vous pouvez simplement laisser bogofilter gérer le
        problème. Entraînez le avec des messages asiatiques
        identifiés comme spam. Bogofilter analysera les messages du
        mieux qu'il peut et ajoutera des tokens à la liste des mots
        de spam. La liste des mots contiendra beaucoup de tokens
        qui n'auront pas de sens pour vous (puisque la table de
        caractères ne peut être affichée), mais Bogofilter peut
        travailler avec eux et identifier correctement du spam
        asiatique.</p>
      </li>

      <li>Une seconde méthode est d'utiliser l'option du fichier de
      configuration "replace_nonascii_characters". Ceci remplacera
      les caractères à code ASCII "haut" (ceux compris entre 0x80
      et 0xFF) avec des points d'interrogations '?'. Ceci permet de
      garder une base de petite taille. Malheureusement ceci entre
      en conflit avec les langues européennes qui contiennent
      beaucoup de voyelles et de consonnes accentuées à code ASCII
      "haut".</li>

      <li>Si vous êtes sûr de ne jamais recevoir un message
      légitime dans ces langues, vous pouvez directement les
      détruire. Cela diminuera la base d'autant. Vous pouvez le
      faire avec un script MDA.</li>

      <li>Ceci est un script qui effacera les messages écrits avec
      les tables de caractères asiatiques</li>

      <li>
	<pre>## Efface silencieusement tous les mails en langue asiatique
	UNREADABLE='[^?"]*big5|iso-2022-jp|ISO-2022-KR|euc-kr|gb2312|ks_c_5601-1987'
	:0:
	* 1^0 $ ^Subject:.*=\?($UNREADABLE)
	* 1^0 $ ^Content-Type:.*charset="?($UNREADABLE)
	spam-unreadable

	:0:
	* ^Content-Type:.*multipart
	* B?? $ ^Content-Type:.*^?.*charset="?($UNREADABLE)
	spam-unreadable</pre>

        <p>Avec un tel programme, Bogofilter ne verra <i>jamais</i>
        le message.</p>
      </li>
    </ul>

    <hr>

    <h2 id="query-database">Comment faire une requête manuelle sur
    la base?</h2>

    <p>Pour trouver le nombre de spam et ham pour un token (mot),
    utiliser l'option '-w' de bogoutil. Par exemple, "bogoutil -w
    $BOGOFILTER_DIR/wordlist.db example.com" fournit le nombre de ham
    et spam pour "example.com".</p>

    <p>Si vous voulez le score de spamicité en plus du nombre de ham
    et spam pour un token, utilisez l'option '-p' de bogoutil.  Par
    exemple, "bogoutil -p $BOGOFILTER_DIR/wordlist.db example.com"
    fournit en plus des nombres ham et spam, le score du mot.</p>

    <p>Pour trouver combien de messages sont dans votre liste de mots,
    faites une requête sur le pseudo-token ".MSG_COUNT" (avec le point
    devant NdT). Par exemple, lancez la commande "bogoutil -w
    $BOGOFILTER_DIR/wordlist.db .MSG_COUNT".</p>

    <p>Pour dire combien de tokens sont présents dans votre liste de
    mots, envoyez la sortie de la commande dump de bogoutil vers la
    commande "wc". Par exemple utilisez "bogoutil -d
    $BOGOFILTER_DIR/wordlist.db/wordlist.db | wc -l " pour afficher le
    nombre d'apparitions des tokens (Si vous utilisez spamlist.db et
    goodlist.db, lancez la commande pour chacun d'eux).</p>

    <hr>

    <h2 id="page-notfound">Comment se fait-il que j'obtienne des messages DB_PAGE_NOTFOUND ?</h2>

    <p>Vous avez certainement un problème avec votre base de données BerkeleyDB. Il y
    a deux causes probables : soit vous avez atteint une taille limite, ou bien, la base
    est corrompue.</p>

    <p>Certains serveurs de messagerie, tel Postfix, impose une taille de fichier limite.
    Quand la base de données Bogofilter atteint cette limite, des problèmes d'écriture
    apparaissent.</p>

    <p>Pour voir la taille utilisée par la base de données:</p>
    <pre>	ls -lh $BOGOFILTER_DIR/wordlist.db</pre>

    <p>Pour voir la taille limite avec postfix:</p>
    <pre>	postconf | grep mailbox_size_limit</pre>

    <p>Pour positionner la taille limite à 73MB (ou n'importe quelle taille appropriée):</p>
    <pre>	postconf -e mailbox_size_limit=73000000</pre>

    <p>Si vous pensez que votre base de données est corrompue, lisez le point
    <a href="#rescue">Comment faire si ma liste de mots est corroumpue ?</a>
    de la FAQ.</p>

    <hr>

    <h2 id="rescue">Comment faire si ma liste de mots est
    corrompue?</h2>

    <p>Si vous pensez que vos listes de mots ont été dégradées,
    vous pouvez regarder ce qu'en dit BerkeleyDB en lançant:</p>
    <pre>	db_verify wordlist.db</pre>

    <p>S'il y a un problème, vous pouvez récupérer tout ou partie
    des tokens et leur nombre avec la commande suivante:</p>
    <pre>	bogoutil -d wordlist.db | bogoutil -l wordlist.db.new</pre>

    <p>ou - si la liste ne pourrait pas être récupérée par la
    commande précédente - avec:</p>
    <pre>	db_dump -r wordlist.db &gt; wordlist.txt
    db_load wordlist.new &lt; wordlist.txt</pre>

    <hr>
    
    <h2 id="update">Comment puis-je faire pour transformer la base des
    mots séparé dans le nouveau format combiné ?</h2>

    <p>Lancez le script bogoupgrade. Pour plus d'informations
    lancez "bogoupgrade -h" pour voir le message d'aide ou "man bogoupgrade"
    et lisez la page manuel.</p>

    <hr>

    <h2 id="multiple">Puis-je utiliser plusieurs listes de mots ?</h2>

    <p>Oui. Bogofilter peut travailler avec plusieurs listes de mots. Par exemple,
    si vous avez des listes <code>utilisateur</code> et
    <code>systeme</code>, Bogofilter peut vérifier si le mot se trouve dans
    la liste utilisateur, et si le mot ne s'y trouve pas, vérifier la liste systeme.
    Bogofilter peut aussi mixer ensemble l'information des deux listes.</p>

    <p>Voici par les options du fichier de configuration et quelques exemples:</p>

    <p>Une liste de mots possède plusieurs attributs, particulièrement le type, le
    nom, le nom de fichier et la précédence.</p>

    <ul>

      <li>Le type: 'R' et 'I' (pour Regular et Ignore). Les listes actuelles
      sont de type 'R'. Le type 'I' signifie "n'évalue pas le token s'il est trouvé
      dans la liste ignore".</li>

      <li>Nom: un identifiant court qui sera utilisé pour l'affichage de messages
      d'erreur. Par exemple "global", "utilisateur" et "ignore". Mais n'importe
      quel identifiant est valide.</li>

      <li>Nom du fichier: le nom  du fichier des mots. Quand
      on ouvre la base, si le chemin est complètement qualifié (avec un '/' en tête,
      ou '~') le nom est utilisé, sinon Bogofilter ajoute le contenu des variables de
      chemin dans l'ordre suivant : $BOGOFILTER_DIR, $BOGODIR, $HOME.</li>

      <li>Précédence: c'est un entier tel que 1, 2, 3, ...  On recherche le token dans 
      les listes de mots dans le sens ascendant de la précédence. Si le
      token est trouvé, les listes de même précédence sont utilisées pour faire
      la somme des comptes. Les listes avec une précédence supérieure, ne
      sont pas vérifiées.</li>

    </ul>

    <p>Exemple 1 - mixage des listes systeme et utilisateur:</p>

    <pre>  wordlist R,utilisateur,~/wordlist.db,1
  wordlist R,systeme,/var/spool/bogofilter/wordlist.db,1</pre>

    <p>Exemple 2 - priorité à la liste utilisateur:</p>

    <pre>  wordlist R,utilisateur,~/wordlist.db,2
  wordlist R,systeme,/var/spool/bogofilter/wordlist.db,3</pre>

    <p>Exemple 3 - priorité à la liste systeme:</p>

    <pre>  wordlist R,utilisateur,~/wordlist.db,5
  wordlist R,systeme,/var/spool/bogofilter/wordlist.db,4</pre>

    <p>Note 1: les options d'enregristrement de Bogofilter ('-s', '-n', '-u',
    '-S', '-N' ) ne s'appliqueront qu'aux listes les plus basses en précédence.</p>

    <p>Note 2: avoir des listes de type 'R' et 'I' de même précédence
    n'est pas autorisé, car les types sont contradictoires.</p>

    <hr>

    <h2 id="ignore">Puis-je indiquer à Bogofilter d'ignorer certains tokens ?</h2>

    <p>A travers l'utilisation des listes de type "ignore", Bogofilter ne prendra
    pas en compte les tokens listés pour évaluer le message.</p>

    <p>Exemple:</p>

    <pre>  wordlist I,ignore,~/ignorelist.db,7
  wordlist R,systeme,/var/spool/bogofilter/wordlist.db,8</pre>

    <p>Puisque <code>ignorelist.db</code> a un index inférieur (7), à celui de
    <code>wordlist.db</code> (8), Bogofilter ne regardera pas les tokens
    qui se trouveront dans <code>ignorelist.db</code>.</p>

    <p>Note: Techniquement, Bogofilter donne le score de ROBX aux tokens, et
    s'attend à ce que le paramètre min_dev les fasse "annuler".</p>

    <p>Il y a deux méthodes principales pour construire/maintenir une liste "ignore".</p>

    <p>Primo, un fichier texte peut être créé et maintenu à l'aide d'un éditeur.
    Bogoutil peut alors convertir le fichier texte en base de données,
    e.g. "bogoutil -l ignorelist.db &lt; ignorelist.txt".</p>

    <p>Secondo, <code>echo ... | bogoutil ...</code> peut être utilisé pour
    ajouter un simple token, par exemple "ignorez.moi" :</p>

    <pre>  echo ignorez.moi | bogoutil -l ~/ignorelist.db</pre>

    <hr>

    <h2 id="nfs">Puis-je partager une liste de mots par NFS?</h2>

    <p>Si vous ne faites que les lire, il n'y a pas de problème.
    Si vous les mettez à jour, vous devrez fournir les bonnes options de verrouillage
    pour éviter la corruption des données. Quand vous compilerez
    Bogofilter, vous aurez besoin de vérifier que le script
    configure a positionné "#define HAVE_FCNTL 1" dans votre
    fichier config.h. Les systèmes d'exploitation UNIX supporteront
    quasiment tous ceci. Si vous utilisez une version exotique ou
    particulièrement ancienne, assurez-vous qu'elle supporte
    fcntl(). Si "#define HAVE_FCNTL 1" est positionné, ce qui indique
    que votre système connaît la fonction fcntl(), alors
    décommentez "#define HAVE_FLOCK 1" afin que le système de
    verrouillage utilise fcntl() au lieu du verrouillage flock().
    Si votre système ne supporte pas fcntl, alors vous ne pourrez
    partager les listes de mots en NFS sans risquer une corruption
    des données.</p>

    <p>Ensuite, assurez-vous que NFS est correctement configuré
    avec "lockd" en fonctionnement. Référez vous à la documentation
    NFS à propos du lancement de "lockd" ou de "rpc.lockd". La
    plupart des systèmes avec NFS l'active par défaut.</p>

    <hr>

    <h2 id="return-codes">Pourquoi Bogofilter fournit des codes de
    retour tels que 0 et 256 quand il est lancé à l'intérieur d'un
    programme?</h2>

    <p>Vraisemblablement les codes de retour ont été réécrits par
    waitpid(2). En C utilisez WEXITSTATUS(status) dans sys/wait.h, ou
    une macro comparable pour obtenir la valeur correcte. En Perl
    utilisez 'system("bogofilter $input")&gt;&gt; 8'. 
    Si vous voulez plus d'information, lancez la commande
    <code>"man waitpid"</code>.</p>
    <hr>

    <h2 id="changed-options">Pourquoi mes scripts échouent depuis
    que j'ai mis à jour?</h2>

    <p>Au fur et à mesure, Bogofilter a accumulé un grand nombre d'options.
    Certaines d'entre elles ont disparu ou changé. Lisez le fichier
    <a href="http://bogofilter.sourceforge.net/NEWS">NEWS</a> pour plus d'informations.</p>

   <hr>

      <h2 id="changed-tagging">Pourquoi, depuis que j'ai changé de version,
       Bogofilter fonctionne-t-il moins bien?</h2>
      <p>Le lexer, la partie qui extrait les tokens des messages, évolue. Ceci
      occasionne une modification de la génération de la liste des tokens, qui, par contrecoups
      va rendre des anciens tokens inutilisés.</p>
      
      <p>Si vous rencontrez ce problème, vous êtes vivement encouragés à reconstruire votre
      base. Si cela n'est pas possible, vous pouvez utiliser la version 
      <a href="http://sourceforge.net/project/showfiles.php?group_id=62265&amp;package_id=59357">0.15.13</a>
      et lire la documentation qui va avec pour voir comment migrer.</p>

      <hr>
      <h2 id="remove-spam-or-nonspam"> Avec une wordlist combinée, comment
          puis-je détruire tous les tokens spams (ou les non-spams) ?</h2>

      <p>Bogoutil vous permet de lister (dump) une wordlist et de charger les tokens dans
      une nouvelle wordlist. Avec l'aide d'outils tels que awk et grep, les nombres peuvent
      être mis à zéros et les tokens dont les comptes seraient à
      zéro pour les spams et les hams pourraient être détruits.</p>
   
      <p>Les commandes suivantes vont détruire les tokens des messages
      spams:</p>

      <pre>    bogoutil -d wordlist.db | \
       awk '{print $1 " " $2 " 0"}' | grep -v " 0 0" | \
       bogoutil -l wordlist.new.db
      </pre>

       <p>Les commandes suivantes vont détruire les tokens provenant des
       messages hams.</p>
   <pre>	bogoutil -d wordlist.db | \
	awk '{print $1 " 0 " $3}' | grep -v " 0 0" | \
	bogoutil -l wordlist.new.db
   </pre>

    <hr>

    <h2 id="port-notes">Comment faire fonctionner Bogofilter sur
    Solaris, BSD, etc.?</h2>

    <p>Si vous n'avez pas déjà la version 3.0 ou plus de la <a href="http://www.sleepycat.com/">BerkeleyDB</a>, alors <a href="http://www.sleepycat.com/download/db/index.shtml">téléchargez la
	(prenez une des 4.2.X)</a>,
    décompactez la, et lancez les commandes suivantes dans le
    répertoire 'dist':</p>
<pre>	$ cd build_unix
	$ sh ../dist/configure
	$ make
	# make install</pre>

    <p>Puis, téléchargez la <a href="http://sourceforge.net/project/showfiles.php?group_id=62265">version
    portable</a> de Bogofilter.</p>

    <h3>Sur Solaris</h3>

    <p>Décompactez la, puis faites:</p>
    <pre>	$ ./configure --with-libdb-prefix=/usr/local/BerkeleyDB-4.2
	$ make
	# make install-strip</pre>

    <p>Vous pourrez alors, soit mettre un lien symbolique sur
    libdb.so dans /usr/lib, ou utiliser une version modifiée de la
    variable d'environnement LD_LIBRARY_PATH avant de lancer
    Bogofilter.</p>
    <pre>	$ LD_LIBRARY_PATH=/usr/lib:/usr/local/lib:/usr/local/BerkeleyDB-4.2
    	$ export LD_LIBRARY_PATH</pre>

    <p>Notez que que certaines versions de make livrées avec
    Solaris bugguent quand vous essayez de compiler Bogofilter hors
    de son répertoire source. Soit vous compilez dans le répertoire
    source (comme suggéré ci-avant), soit vous utilisez GNU make
    (gmake).</p>

    <h3>Sur FreeBSD</h3>

    <p>Des paquetages existent avec des versions très récentes de
    Bogofilter. Cette approche utilise les paquetages très
    recommandés portupgrade et cvsup. Pour installer ces deux
    magnifiques outils (vous n'avez besoin de le faire qu'une seule
    fois):</p>
    <pre>	# pkg_add -r portupgrade cvsup</pre>

    <p>Pour installer ou mettre à jour Bogofilter, il suffit de
    mettre à jour <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/cvsup.html">
    l'arbre de conversion (ports tree) avec cvsup</a> puis de
    taper</p>
    <pre>	# portupgrade -N bogofilter</pre>

    <p><em>Note: Ceci suppose que vous soyez root.</em> Sinon, lisez
    le mémento sur la section FreeBSC, et regardez comment 
    <a href="#build">compiler</a> si vous n'avez pas les privilèges requis..</p>

    <p>Suivant votre système, vous pourrez avoir à positionner certaines variables
    d'environnement pour la commande <code>./configure</code>. Exemple:</p>

    <pre>	# env CPPFLAGS=-I/usr/local/include/db3 LIBS=-ldb3 LDFLAGS=-L/usr/local/lib ./configure</pre>

    <p>Les chemins dépendent de votre système et des versions
    de bases de données que vous avez installées. Vérifiez et remplacez en conséquence.</p>

    <h3>Sur HP-UX</h3>

    <p>Regardez le fichier
    <a href="http://cvs.sourceforge.net/viewcvs.py/*checkout*/bogofilter/bogofilter/doc/programmer/README.hp-ux?rev=HEAD&amp;content-type=text/plain">doc/programmer/README.hp-ux</a>
    dans la distribution source.</p>

    <hr>

    <h2 id="make-notes">Puis-je utiliser la commande make sur mon système ?</h2>

    <p>Bogofilter a été compilé avec succès sur plusieurs systèmes en utilisant
    la commande GNU make et les commandes natives make. Cependant, le Makefile
    de Bogofilter ne fonctionne pas avec certaines commandes make.</p>

    <p>GNU make est recommandé pour compiler Bogofilter car nous savons qu'il fonctionne.
    Nous ne pouvons maintenir des commandes make moins performantes. Si votre make
    non-GNU fonctionne, magnifique !. Si vous rencontrez des problèmes, la chose à faire est 
    d'installer la commande GNU make. Si votre make non-GNU ne peut compiler Bogofilter,
    nous sommes désolés, mais c'est votre problème. Si cela ne nécessite qu'un petit
    patch propre pour le rendre compatible, nous pouvons éventuellement l'intégrer.</p>

    <hr>

    <h2 id="build">Comment compiler Bogofilter pour un utilisateur non-root ou avec
    un préfixe d'installation non standard?</h2>

    <p>Pour installer Bogofilter dans un répertoire non standard (en tant qu'utilisateur
    non-root vous n'avez pas les permissions pour les répertoires normaux), vous
    aurez besoin de préciser le préfixe d'installation quand vous lancerez
     <code>./configure</code>.

    </p><p> Après avoir télécharger et décompacter <a href="http://sourceforge.net/project/showfiles.php?group_id=62265">
    le code source</a>, lancez <code>./configure --prefix=PATH</code> où
    PATH est le préfixe d'installation pour les fichiers générés (binaires, manuel, etc.)
    Puis lancez les commandes habituelles &#8212;
    <code>make &amp;&amp; make check &amp;&amp; make install</code>.
    </p>

    <hr>

    <h2 id="patch">Comment dois-je compiler Bogofilter avec les patches ?</h2>

    <p>S'il vous est nécessaire d'appliquer des correctifs, récupérez
    <a href="http://sourceforge.net/project/showfiles.php?group_id=62265"> le code source
    </a> et décompactez le en utilisant <code>tar -xzf</code> ou <code>gunzip
    | tar -xf -</code>. Placez vous dans le répertoire source et lancez la commande<code>./configure --prefix=PATH</code>
    où
    PATH est le préfixe d'installation pour les fichiers générés (binaires, manuel, etc.)
    Puis, après avoir appliqué les correctifs, lancez les commandes habituelles &#8212;
    <code>make &amp;&amp; make install</code>.

    </p><hr>

    <h2 id="smaller">Comment rendre les exécutables plus petits ?</h2>

    <p>Quand votre espace est réduit, vous pouvez utiliser <code>make
    install-strip</code> en lieu et place de <code>make install</code>.
    Ceci permet d'économiser de l'espace disque, mais ne permet pas le
    debugage lors de crash, à moins que plus d'informations pour reproduire le bug
    ne soient fournies aux développeurs.</p>

    <hr>

    <!--
    $Id$
    -->
 </body></html>
